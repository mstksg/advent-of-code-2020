-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Development environment for Advent of Code challenges
--   
--   Scaffolding for an integrated development environment for Advent of
--   Code challenges. Includes auto-runner, prompt displays and countdowns,
--   and integrated submissions.
@package aoc2020
@version 0.1.0.0

module AOC.Common.DLLC
data Node s a
Node :: MutVar s (Node s a) -> a -> MutVar s (Node s a) -> Node s a
[nLeft] :: Node s a -> MutVar s (Node s a)
[nItem] :: Node s a -> a
[nRight] :: Node s a -> MutVar s (Node s a)
newtype List s a
List :: MutVar s (MutVar s (Node s a)) -> List s a
[getList] :: List s a -> MutVar s (MutVar s (Node s a))
cloneTop :: (PrimMonad m, PrimState m ~ s) => List s a -> m (List s a)
singleton :: (PrimMonad m, PrimState m ~ s) => a -> m (List s a)
fromList :: (PrimMonad m, PrimState m ~ s) => NonEmpty a -> m (List s a)
sourceRight :: (PrimMonad m, PrimState m ~ s) => List s a -> Pipe i a u m ()
sourceRightForever :: (PrimMonad m, PrimState m ~ s) => List s a -> Pipe i a u m r
sourceLeft :: (PrimMonad m, PrimState m ~ s) => List s a -> Pipe i a u m ()
sourceLeftForever :: (PrimMonad m, PrimState m ~ s) => List s a -> Pipe i a u m r
sourceZip :: (PrimMonad m, PrimState m ~ s) => List s a -> Pipe i (a, a) u m ()
readOut :: (PrimMonad m, PrimState m ~ s) => List s a -> m [a]
readFocus :: (PrimMonad m, PrimState m ~ s) => List s a -> m a
modifyFocus :: (PrimMonad m, PrimState m ~ s) => (a -> a) -> List s a -> m ()
readAt :: (PrimMonad m, PrimState m ~ s) => Int -> List s a -> m a
seek :: (PrimMonad m, PrimState m ~ s) => (a -> Bool) -> List s a -> m (Maybe Int)
insertRight :: (PrimMonad m, PrimState m ~ s) => a -> List s a -> m ()
insertLeft :: (PrimMonad m, PrimState m ~ s) => a -> List s a -> m ()
rotateRight :: (PrimMonad m, PrimState m ~ s) => List s a -> m ()
rotateLeft :: (PrimMonad m, PrimState m ~ s) => List s a -> m ()
rotateN :: (PrimMonad m, PrimState m ~ s) => Int -> List s a -> m ()
popRight :: (PrimMonad m, PrimState m ~ s) => List s a -> m a
popLeft :: (PrimMonad m, PrimState m ~ s) => List s a -> m a
instance GHC.Classes.Eq (AOC.Common.DLLC.List s a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AOC.Common.DLLC.Node s a)

module AOC.Common.FinitarySet
newtype FinitarySet a
FinitarySet :: Vector (Cardinality a) Bit -> FinitarySet a
empty :: KnownNat (Cardinality a) => FinitarySet a
singleton :: Finitary a => a -> FinitarySet a
insert :: Finitary a => a -> FinitarySet a -> FinitarySet a
delete :: Finitary a => a -> FinitarySet a -> FinitarySet a
fromList :: Finitary a => [a] -> FinitarySet a
toList :: Finitary a => FinitarySet a -> [a]
intersection :: FinitarySet a -> FinitarySet a -> FinitarySet a
union :: FinitarySet a -> FinitarySet a -> FinitarySet a
unions :: Finitary a => [FinitarySet a] -> FinitarySet a
difference :: FinitarySet a -> FinitarySet a -> FinitarySet a
(\\) :: FinitarySet a -> FinitarySet a -> FinitarySet a
infixl 9 \\
isSubsetOf :: FinitarySet a -> FinitarySet a -> Bool
isProperSubsetOf :: FinitarySet a -> FinitarySet a -> Bool
disjoint :: FinitarySet a -> FinitarySet a -> Bool
size :: FinitarySet a -> Int
member :: Finitary a => a -> FinitarySet a -> Bool
notMember :: Finitary a => a -> FinitarySet a -> Bool
null :: FinitarySet a -> Bool
cartesianProduct :: (KnownNat (Cardinality a), KnownNat (Cardinality a * Cardinality b)) => FinitarySet a -> FinitarySet b -> FinitarySet (a, b)
disjointUnion :: FinitarySet a -> FinitarySet b -> FinitarySet (Either a b)
foldr :: Finitary a => (a -> b -> b) -> b -> FinitarySet a -> b
foldr' :: Finitary a => (a -> b -> b) -> b -> FinitarySet a -> b
foldl :: Finitary a => (b -> a -> b) -> b -> FinitarySet a -> b
foldl' :: Finitary a => (b -> a -> b) -> b -> FinitarySet a -> b
map :: (Finitary a, Finitary b) => (a -> b) -> FinitarySet a -> FinitarySet b
foldMap :: (Finitary a, Monoid m) => (a -> m) -> FinitarySet a -> m
filter :: Finitary a => (a -> Bool) -> FinitarySet a -> FinitarySet a
alterF :: (Finitary a, Functor f) => (Bool -> f Bool) -> a -> FinitarySet a -> f (FinitarySet a)
generate :: Finitary a => (a -> Bool) -> FinitarySet a
powerSet :: (Finitary a, KnownNat (2 ^ Cardinality a)) => FinitarySet a -> FinitarySet (FinitarySet a)
mapMaybe :: (Finitary a, Finitary b) => (a -> Maybe b) -> FinitarySet a -> FinitarySet b
partition :: Finitary a => (a -> Bool) -> FinitarySet a -> (FinitarySet a, FinitarySet a)
instance GHC.Classes.Ord (AOC.Common.FinitarySet.FinitarySet a)
instance GHC.Classes.Eq (AOC.Common.FinitarySet.FinitarySet a)
instance GHC.Generics.Generic (AOC.Common.FinitarySet.FinitarySet a)
instance GHC.Show.Show (AOC.Common.FinitarySet.FinitarySet a)
instance (Data.Finitary.Finitary a, GHC.TypeNats.KnownNat (2 GHC.TypeNats.^ Data.Finitary.Cardinality a)) => Data.Finitary.Finitary (AOC.Common.FinitarySet.FinitarySet a)
instance Control.DeepSeq.NFData (AOC.Common.FinitarySet.FinitarySet a)

module AOC.Common.Numeric
data PascalTable
PascalTable :: !Int -> !Int -> !Vector Int -> PascalTable
[ptWidth] :: PascalTable -> !Int
[ptDepth] :: PascalTable -> !Int
[ptTable] :: PascalTable -> !Vector Int
buildPascalTable :: Int -> Int -> PascalTable
binom :: PascalTable -> Int -> Int -> Int
pascals :: [[Int]]
instance GHC.Show.Show AOC.Common.Numeric.PascalTable

module AOC.Common.Point

-- | 2D Coordinate
type Point = V2 Int
type FinPoint n = V2 (Finite n)
cardinalNeighbs :: Point -> [Point]
cardinalNeighbsSet :: Point -> Set Point
fullNeighbs :: (Applicative f, Num a, Traversable f) => f a -> [f a]
fullNeighbsSet :: (Applicative f, Num a, Ord (f a), Traversable f) => f a -> Set (f a)
mannDist :: (Foldable f, Num a, Num (f a)) => f a -> f a -> a

-- | Treat as complex number multiplication. useful for rotations
mulPoint :: Num a => V2 a -> V2 a -> V2 a

-- | Lattice points for line between points, not including endpoints
lineTo :: Point -> Point -> [Point]
data Dir
North :: Dir
East :: Dir
South :: Dir
West :: Dir
parseDir :: Char -> Maybe Dir
dirPoint :: Num a => Dir -> V2 a

-- | <a>dirPoint</a> but with inverted y axis
dirPoint' :: Num a => Dir -> V2 a

-- | Rotate a point by a direction
rotPoint :: Num a => Dir -> V2 a -> V2 a

-- | Rotate a point by a direction
rotFin :: KnownNat n => Dir -> FinPoint n -> FinPoint n

-- | Multiply headings, taking North as straight, East as clockwise turn,
--   West as counter-clockwise turn, and South as reverse.
--   
--   Should be a commutative group; it's essentially complex number
--   multiplication like <a>mulPoint</a>, with North = 1, West = i. The
--   identity is <a>North</a> and the inverse is the opposite direction.
mulDir :: Dir -> Dir -> Dir
allDir :: NonEmpty Dir
allDirSet :: NESet Dir

-- | Represents an orientation of a 2d tile.
data D8
D8 :: !Dir -> !Bool -> D8
[d8Rot] :: D8 -> !Dir
[d8Flip] :: D8 -> !Bool

-- | <tt>a <a>mulD8</a> b</tt> represents applying b, then a.
mulD8 :: D8 -> D8 -> D8

-- | Rotate and flip a point by a <a>D8</a>
orientPoint :: Num a => D8 -> V2 a -> V2 a
orientFin :: KnownNat n => D8 -> FinPoint n -> FinPoint n
allD8 :: NonEmpty D8
allD8Set :: NESet D8
memoPoint :: Memo Point

-- | Find the minimum and maximum x and y from a collection of points.
--   
--   Returns <tt><a>V2</a> (V2 xMin yMin) (V2 xMax yMax)</tt>.
boundingBox :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> V2 (g a)

-- | A version of <a>boundingBox</a> that works for normal possibly-empty
--   lists.
boundingBox' :: (Foldable f, Applicative g, Ord a) => f (g a) -> Maybe (V2 (g a))
inBoundingBox :: (Applicative g, Foldable g, Ord a) => V2 (g a) -> g a -> Bool
minCorner :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> g a
minCorner' :: (Foldable f, Applicative g, Ord a) => f (g a) -> Maybe (g a)

-- | Shift corner to (0,0)
shiftToZero :: (Applicative f, Num a, Ord a) => NESet (f a) -> NESet (f a)

-- | Shift corner to (0,0)
shiftToZero' :: (Applicative f, Num a, Ord a) => Set (f a) -> Set (f a)
parseAsciiMap :: (Char -> Maybe a) -> String -> Map Point a
asciiGrid :: IndexedTraversal Point String [a] Char a
parseAsciiSet :: (Char -> Bool) -> String -> Set Point

-- | It's <a>Point</a>, but with a newtype wrapper so we have an <a>Ord</a>
--   that sorts by y first, then x
newtype ScanPoint
SP :: Point -> ScanPoint
[_getSP] :: ScanPoint -> Point
displayAsciiMap :: Char -> Map Point Char -> String
displayAsciiSet :: Char -> Char -> Set Point -> String
centeredFinite :: forall n. KnownNat n => Iso' (Finite n) Rational
instance GHC.Num.Num AOC.Common.Point.ScanPoint
instance GHC.Generics.Generic AOC.Common.Point.ScanPoint
instance GHC.Show.Show AOC.Common.Point.ScanPoint
instance GHC.Classes.Eq AOC.Common.Point.ScanPoint
instance GHC.Generics.Generic AOC.Common.Point.D8
instance GHC.Classes.Ord AOC.Common.Point.D8
instance GHC.Classes.Eq AOC.Common.Point.D8
instance GHC.Show.Show AOC.Common.Point.D8
instance GHC.Enum.Enum AOC.Common.Point.Dir
instance GHC.Generics.Generic AOC.Common.Point.Dir
instance GHC.Classes.Ord AOC.Common.Point.Dir
instance GHC.Classes.Eq AOC.Common.Point.Dir
instance GHC.Show.Show AOC.Common.Point.Dir
instance Data.Hashable.Class.Hashable AOC.Common.Point.ScanPoint
instance Control.DeepSeq.NFData AOC.Common.Point.ScanPoint
instance GHC.Classes.Ord AOC.Common.Point.ScanPoint
instance Data.Hashable.Class.Hashable AOC.Common.Point.D8
instance Control.DeepSeq.NFData AOC.Common.Point.D8
instance Data.Finitary.Finitary AOC.Common.Point.D8
instance GHC.Base.Semigroup AOC.Common.Point.D8
instance GHC.Base.Monoid AOC.Common.Point.D8
instance Data.Group.Group AOC.Common.Point.D8
instance Data.Hashable.Class.Hashable AOC.Common.Point.Dir
instance Control.DeepSeq.NFData AOC.Common.Point.Dir
instance Data.Finitary.Finitary AOC.Common.Point.Dir
instance GHC.Base.Semigroup AOC.Common.Point.Dir
instance GHC.Base.Monoid AOC.Common.Point.Dir
instance Data.Group.Group AOC.Common.Point.Dir
instance Data.Group.Abelian AOC.Common.Point.Dir
instance (Data.Finitary.Finitary a, GHC.TypeNats.KnownNat (Data.Finitary.Cardinality a), GHC.TypeNats.KnownNat (Data.Finitary.Cardinality a GHC.TypeNats.* Data.Finitary.Cardinality a)) => Data.Finitary.Finitary (Linear.V2.V2 a)
instance (Data.Finitary.Finitary a, GHC.TypeNats.KnownNat (Data.Finitary.Cardinality a), GHC.TypeNats.KnownNat (Data.Finitary.Cardinality a GHC.TypeNats.* (Data.Finitary.Cardinality a GHC.TypeNats.* Data.Finitary.Cardinality a))) => Data.Finitary.Finitary (Linear.V3.V3 a)
instance (Data.Finitary.Finitary a, GHC.TypeNats.KnownNat (Data.Finitary.Cardinality a), GHC.TypeNats.KnownNat ((Data.Finitary.Cardinality a GHC.TypeNats.* Data.Finitary.Cardinality a) GHC.TypeNats.* (Data.Finitary.Cardinality a GHC.TypeNats.* Data.Finitary.Cardinality a))) => Data.Finitary.Finitary (Linear.V4.V4 a)

module AOC.Common.Search

-- | A* Search
aStar :: forall n p. (Ord n, Ord p, Num p) => (n -> p) -> (n -> Map n p) -> n -> (n -> Bool) -> Maybe (p, [n])

-- | Breadth-first search, with loop detection
bfs :: forall n. Ord n => (n -> Set n) -> n -> (n -> Bool) -> Maybe [n]
binarySearch :: (Int -> Ordering) -> Int -> Int -> Maybe Int
exponentialSearch :: (Int -> Ordering) -> Int -> Maybe Int

-- | Find the lowest value where the predicate is satisfied within the
--   given bounds.
binaryMinSearch :: (Int -> Bool) -> Int -> Int -> Maybe Int

-- | Find the lowest value where the predicate is satisfied above a given
--   bound.
exponentialMinSearch :: (Int -> Bool) -> Int -> Maybe Int

-- | Find the lowest value where the predicate is <a>Just</a> within the
--   given bounds.
binaryFindMin :: (Int -> Maybe a) -> Int -> Int -> Maybe a

-- | Find the lowest value where the predicate is <a>Just</a> above a given
--   bound.
exponentialFindMin :: (Int -> Maybe a) -> Int -> Maybe a


-- | Utilities for loading configuration file.
module AOC.Run.Config

-- | Configuration for auto-runner.
data Config
Cfg :: Maybe String -> Integer -> Config

-- | Default: <a>Nothing</a>
[_cfgSession] :: Config -> Maybe String

-- | Default: 2015
[_cfgYear] :: Config -> Integer

-- | Load a <a>Config</a> from a given filepath.
configFile :: FilePath -> IO Config

-- | Default math to find a configuration file.
defConfPath :: FilePath

-- | Load a session token from the configuration file at a given filepath.
session :: FilePath -> IO (Maybe String)
instance GHC.Generics.Generic AOC.Run.Config.Config
instance Data.Default.Class.Default AOC.Run.Config.Config
instance Data.Aeson.Types.ToJSON.ToJSON AOC.Run.Config.Config
instance Data.Aeson.Types.FromJSON.FromJSON AOC.Run.Config.Config


-- | Assorted utility functions and orphans used for solutions.
module AOC.Util

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Strip trailing newline
stripNewline :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a

-- | Generalize a <a>Maybe</a> to any <a>Alternative</a>
maybeAlt :: Alternative m => Maybe a -> m a

-- | Like <a>traceShowId</a> but with an extra message
traceShowIdMsg :: Show a => String -> a -> a

-- | Like <a>traceShow</a> but with an extra message
traceShowMsg :: Show a => String -> a -> b -> b


-- | Common functions for solutions
module AOC.Common

-- | trace but only after something has evaluated to WHNF
trace' :: String -> a -> a

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]

-- | Apply function until <a>Nothing</a> is produced, and return last
--   produced value.
loopMaybe :: (a -> Maybe a) -> a -> a

-- | Apply monadic function until <a>Nothing</a> is produced, and return
--   last produced value.
loopMaybeM :: Monad m => (a -> m (Maybe a)) -> a -> m a

-- | Apply function until a <a>Left</a>.
loopEither :: (a -> Either r a) -> a -> r

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Strict (!!)
(!!!) :: [a] -> Int -> a
strictIterate :: (a -> a) -> a -> [a]
(!?) :: [a] -> Int -> Maybe a

-- | Strict drop
drop' :: Int -> [a] -> [a]

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Lazily find the first repeated projection.
firstRepeatedBy :: Ord a => (b -> a) -> [b] -> Maybe b

-- | Repeat a function until you get the same result twice.
fixedPoint :: Eq a => (a -> a) -> a -> a

-- | Flood fill from a starting set
floodFill :: Ord a => (a -> Set a) -> Set a -> Set a

-- | Flood fill from a starting set, counting the number of steps
floodFillCount :: Ord a => (a -> Set a) -> Set a -> (Int, Set a)

-- | Count the number of items in a container where the predicate is true.
countTrue :: Foldable f => (a -> Bool) -> f a -> Int

-- | Given a map of <tt>k</tt> to possible <tt>a</tt>s for that <tt>k</tt>,
--   find possible configurations where each <tt>k</tt> is given its own
--   unique <tt>a</tt>.
pickUnique :: (Ord k, Ord a) => [(k, Set a)] -> [Map k a]

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | Look up a count from a frequency map, defaulting to zero if item is
--   not foudn
lookupFreq :: Ord a => a -> Map a Int -> Int

-- | Build a list of <i>descending</i> frequencies. Ties are sorted.
freqList :: (Foldable f, Ord a) => f a -> [(Int, a)]

-- | Build a reverse frequency map
revFreq :: (Foldable f, Ord a) => f a -> IntMap (NESet a)

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: Traversable f => (a -> [a]) -> f a -> [f a]

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbationsBy :: Conjoined p => Over p (Bazaar p a a) s t a a -> (a -> [a]) -> s -> [t]

-- | each item paired with the list not including that item
select :: [a] -> [(a, [a])]

-- | sliding windows of a given length
slidingWindows :: Int -> [a] -> [Seq a]

-- | sorted windows of a given length
sortedSlidingWindows :: forall k v. Ord k => Int -> [(k, v)] -> [OrdPSQ k Int v]

-- | sorted windows of a given length
sortedSlidingWindowsInt :: forall v. () => Int -> [(Int, v)] -> [IntPSQ Int v]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <tt>foldMap1</tt>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b
foldMapParChunk :: forall a m. (NFData m, Monoid m) => Int -> (a -> m) -> [a] -> m

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)
listTup :: [a] -> Maybe (a, a)
_ListTup :: Prism' [a] (a, a)
listTup3 :: [a] -> Maybe (a, a, a)
_ListTup3 :: Prism' [a] (a, a, a)
listTup4 :: [a] -> Maybe (a, a, a, a)
_ListTup4 :: Prism' [a] (a, a, a, a)
sortSizedBy :: Vector v a => (a -> a -> Ordering) -> Vector v n a -> Vector v n a
withAllSized :: Vector v a => NonEmpty [a] -> (forall n. KnownNat n => NonEmpty (Vector v n a) -> Maybe r) -> Maybe r
binaryFold :: Monoid m => Int -> (a -> m) -> [a] -> m
binaryFoldPar :: Monoid m => Int -> (a -> m) -> [a] -> m

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)
type Letter = Finite 26

-- | Parse a letter into a number 0 to 25. Returns <a>False</a> if
--   lowercase and <a>True</a> if uppercase.
charFinite :: Char -> Maybe (Bool, Finite 26)

-- | Prism for a <a>Char</a> as <tt>(<a>Bool</a>, <a>Finite</a> 26)</tt>,
--   where the <a>Finite</a> is the letter parsed as a number from 0 to 25,
--   and the <a>Bool</a> is lowercase (<a>False</a>) or uppercase
--   (<a>True</a>).
_CharFinite :: Prism' Char (Bool, Finite 26)
hexDigit :: Prism' Char (Finite 16)
decimalDigit :: Prism' Char (Finite 10)
splitWord :: Word8 -> (Finite 16, Finite 16)
digitToIntSafe :: Char -> Maybe Int

-- | Caeser shift, preserving case. If you have an <a>Int</a> or
--   <a>Integer</a>, convert into <a>Finite</a> using <a>modulo</a>.
caeser :: Finite 26 -> Char -> Char
eitherItem :: Lens' (Either a a) a
getDown :: Down a -> a
toNatural :: Integral a => a -> Maybe Natural
factorial :: Int -> Int
integerFactorial :: Integer -> Integer
mapMaybeSet :: Ord b => (a -> Maybe b) -> Set a -> Set b
symDiff :: Ord a => Set a -> Set a -> Set a
unfoldedIterate :: forall n a proxy. InlineInduction n => proxy n -> (a -> a) -> a -> a
memo4 :: Memo a -> Memo b -> Memo c -> Memo d -> (a -> b -> c -> d -> r) -> a -> b -> c -> d -> r

-- | Use a stream of tokens <tt>a</tt> as the underlying parser stream.
--   Note that error messages for parser errors are going necessarily to be
--   wonky.
newtype TokStream a
TokStream :: [a] -> TokStream a
[getTokStream] :: TokStream a -> [a]

-- | Parse a stream of tokens <tt>s</tt> purely, returning <a>Either</a>
parseTokStream :: Foldable t => Parsec e (TokStream s) a -> t s -> Either (ParseErrorBundle (TokStream s) e) a

-- | Parse a stream of tokens <tt>s</tt> purely
parseTokStream_ :: (Alternative m, Foldable t) => Parsec e (TokStream s) a -> t s -> m a

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad,
--   returning <a>Either</a>
parseTokStreamT :: (Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (Either (ParseErrorBundle (TokStream s) e) a)

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad
parseTokStreamT_ :: (Alternative f, Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (f a)
type TokParser s = Parsec Void (TokStream s)
parseWords :: Parsec Void (TokStream String) a -> String -> Maybe a

-- | Skip every result until this token matches
nextMatch :: MonadParsec e s m => m a -> m a
parseMaybeLenient :: Parsec Void s a -> s -> Maybe a
parseOrFail :: (Stream s, ShowErrorComponent e) => Parsec e s a -> s -> a
type CharParser = Parsec Void String
pWord :: (Stream s, Token s ~ Char, Ord e) => Parsec e s String
pHWord :: (Stream s, Token s ~ Char, Ord e) => Parsec e s String
pDecimal :: (Stream s, Token s ~ Char, Ord e, Num a) => Parsec e s a
pTok :: (Stream s, Token s ~ Char, Ord e) => Parsec e s a -> Parsec e s a
pSpace :: (Stream s, Token s ~ Char, Ord e) => Parsec e s ()
parseLines :: Parsec Void String a -> String -> Maybe [a]
type Graph v e = Map v (Map v e)
toFGL :: (Graph gr, Ord v) => Graph v e -> (gr v e, Set v)
anaM :: (Monad m, Corecursive t, Traversable (Base t)) => (a -> m (Base t a)) -> a -> m t
data TreeF a b
NodeF :: a -> ForestF a b -> TreeF a b
type ForestF a b = [b]
instance GHC.Generics.Generic (AOC.Common.TreeF a b)
instance GHC.Base.Functor (AOC.Common.TreeF a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (AOC.Common.TreeF a b)
instance GHC.Base.Functor AOC.Common.TokStream
instance GHC.Generics.Generic (AOC.Common.TokStream a)
instance GHC.Show.Show a => GHC.Show.Show (AOC.Common.TokStream a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AOC.Common.TokStream a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (AOC.Common.TokStream a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (AOC.Common.TreeF a b)
instance Data.Functor.Foldable.Recursive (Data.Tree.Tree a)
instance Data.Functor.Foldable.Corecursive (Data.Tree.Tree a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (AOC.Common.TokStream a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (AOC.Common.TokStream a)
instance (GHC.Classes.Ord a, GHC.Show.Show a) => Text.Megaparsec.Stream.Stream (AOC.Common.TokStream a)
instance (Control.Lens.At.Ixed (v a), Control.Lens.At.Index (v a) GHC.Types.~ GHC.Types.Int, Control.Lens.At.IxValue (v a) GHC.Types.~ a) => Control.Lens.At.Ixed (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.TypeNats.KnownNat n, forall a. Data.Vector.Generic.Base.Vector v a, 1 GHC.TypeNats.<= n) => Linear.V1.R1 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance (GHC.TypeNats.KnownNat n, forall a. Data.Vector.Generic.Base.Vector v a, 2 GHC.TypeNats.<= n) => Linear.V2.R2 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance (GHC.TypeNats.KnownNat n, forall a. Data.Vector.Generic.Base.Vector v a, 3 GHC.TypeNats.<= n) => Linear.V3.R3 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance (GHC.TypeNats.KnownNat n, forall a. Data.Vector.Generic.Base.Vector v a, 4 GHC.TypeNats.<= n) => Linear.V4.R4 (Data.Vector.Generic.Sized.Internal.Vector v n)
instance (GHC.Classes.Ord k, GHC.Classes.Ord p) => Control.Lens.At.Ixed (Data.OrdPSQ.Internal.OrdPSQ k p v)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Sequence.Internal.Seq a)
instance Control.Lens.Indexed.FunctorWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)
instance Control.Lens.Indexed.FoldableWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)
instance Control.Lens.Indexed.TraversableWithIndex k (Data.Map.NonEmpty.Internal.NEMap k)

module AOC.Util.DynoMap
newtype DynoMap
Dyno :: Map String Dynamic -> DynoMap
[runDyno] :: DynoMap -> Map String Dynamic

-- | Lookup the value at a given key in a <a>Dyno</a>.
--   
--   <pre>
--   lookupDyno "hello"
--   </pre>
lookupDyno :: forall a. Typeable a => String -> DynoMap -> Maybe a

-- | Like <a>lookupDyno</a>, but with a default value to be returned if the
--   key is not found or has the wrong type.
lookupDynoWith :: forall a. Typeable a => String -> a -> DynoMap -> a
instance GHC.Base.Monoid AOC.Util.DynoMap.DynoMap
instance GHC.Base.Semigroup AOC.Util.DynoMap.DynoMap


-- | Types to drive the challenge runner and help speed up/clean up
--   solutions.
module AOC.Solver

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> ((?dyno :: DynoMap) => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> (?dyno :: DynoMap) => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSolWH] :: (a :~> b) -> SomeSolution
[MkSomeSolNF] :: (NFData a, NFData b) => (a :~> b) -> SomeSolution

-- | Handy pattern to work with both <a>MkSomeSolWH</a> and
--   <a>MkSomeSolNF</a>. As a constructor, just uses <a>MkSomeSolWH</a>, so
--   might not be desirable.
pattern MkSomeSol :: () => forall a b. () => (a :~> b) -> SomeSolution

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Check if a <a>SomeSolution</a> is equipped with an <a>NFData</a>
--   instance on the types
ssIsNF :: SomeSolution -> Bool

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a
instance GHC.Generics.Generic AOC.Solver.SolutionError
instance GHC.Classes.Ord AOC.Solver.SolutionError
instance GHC.Classes.Eq AOC.Solver.SolutionError
instance GHC.Show.Show AOC.Solver.SolutionError
instance Control.DeepSeq.NFData AOC.Solver.SolutionError


-- | Custom Prelude while developing challenges. Ideally, once challenges
--   are completed, an import to this module would be replaced with
--   explicit ones for future readers.
module AOC.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <a>elem</a> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <a>length</a> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap</a> that is strict in the accumulator.
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <tt>O(n)</tt>
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <a>Data.Monoid</a>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <a>Data.Monoid</a>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | <i>O(1)</i>. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | <i>O(1)</i>. Extract the elements after the head of a list, which must
--   be non-empty.
tail :: [a] -> [a]

-- | <i>O(n)</i>. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | <i>O(n)</i>. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | <i>O(n)</i>. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | <i>O(min(m,n))</i>. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | <i>O(n)</i>. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Uninhabited data type
data Void

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: b -> (a -> b) -> Option a -> b

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min Arg a b
type ArgMax a b = Max Arg a b

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: a

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: Char -> a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: String -> a

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | Format a variable number of arguments with the C-style formatting
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; printf "%s, %d, %.4f" "hello" 123 pi
--   hello, 123, 3.1416
--   </pre>
--   
--   The return value is either <a>String</a> or <tt>(<a>IO</a> a)</tt>
--   (which should be <tt>(<a>IO</a> ())</tt>, but Haskell's type system
--   makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a <i>format character</i> that provides the
--   primary information about how to format the value. The rest of the
--   conversion specification is optional. In order, one may have flag
--   characters, a width specifier, a precision specifier, and
--   type-specific modifier characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
printf :: PrintfType r => String -> r

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <tt>printf(3)</tt> for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See <tt>printf(3)</tt> for the
--   details, which vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <a>MonadIO</a>, <tt><a>liftIO</a> .
--   <a>traceIO</a></tt> may be a better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

putTraceMsg :: String -> IO ()

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
newtype WrappedMonad (m :: Type -> Type) a
WrapMonad :: m a -> WrappedMonad (m :: Type -> Type) a
[unwrapMonad] :: WrappedMonad (m :: Type -> Type) a -> m a
newtype WrappedArrow (a :: Type -> Type -> Type) b c
WrapArrow :: a b c -> WrappedArrow (a :: Type -> Type -> Type) b c
[unwrapArrow] :: WrappedArrow (a :: Type -> Type -> Type) b c -> a b c

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a
unsafeCoerce :: a -> b

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | <i>O(n)</i>. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | <i>O(n)</i>. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
genericLength :: Num i => [a] -> i

-- | <i>O(n)</i>. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | <i>O(n)</i>. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | <i>O(n)</i>. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | <i>O(n)</i>. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | <i>O(min(m,n))</i>. The <a>stripPrefix</a> function drops the given
--   prefix from a list. It returns <a>Nothing</a> if the list did not
--   start with the prefix given, or <a>Just</a> the list after the prefix,
--   if it does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall k (a :: k). a :~: a
infix 4 :~:

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <i>O(n)</i>. A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <i>O(1)</i>. Decompose a list into its head and tail. If the list is
--   empty, returns <a>Nothing</a>. If the list is non-empty, returns
--   <tt><a>Just</a> (x, xs)</tt>, where <tt>x</tt> is the head of the list
--   and <tt>xs</tt> its tail.
uncons :: [a] -> Maybe (a, [a])

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
unsafePerformIO :: IO a -> a

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | The <tt>nubIntOn</tt> function behaves just like <a>nubInt</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype. For example,
--   <tt>nubIntOn <a>fromEnum</a></tt> can be used to nub characters and
--   typical fixed-with numerical types efficiently.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubIntOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubIntOn :: (a -> Int) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubInt</tt> function removes duplicate
--   <a>Int</a> values from a list. In particular, it keeps only the first
--   occurrence of each element. By using an <a>IntSet</a> internally, it
--   attains better asymptotics than the standard <a>nub</a> function.
--   
--   See also <a>nubIntOn</a>, a more widely applicable generalization.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubInt</tt> is strict in the elements of the list.
nubInt :: [Int] -> [Int]

-- | The <tt>nubOrdOn</tt> function behaves just like <a>nubOrd</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrdOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubOrdOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubOrd</tt> function removes duplicate elements
--   from a list. In particular, it keeps only the first occurrence of each
--   element. By using a <a>Set</a> internally it has better asymptotics
--   than the standard <a>nub</a> function.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrd</tt> is strict in the elements of the list.
--   
--   <h4>Efficiency note</h4>
--   
--   When applicable, it is almost always better to use <a>nubInt</a> or
--   <a>nubIntOn</a> instead of this function, although it can be a little
--   worse in certain pathological cases. For example, to nub a list of
--   characters, use
--   
--   <pre>
--   nubIntOn fromEnum xs
--   </pre>
nubOrd :: Ord a => [a] -> [a]

-- | A set of integers.
data IntSet

-- | General-purpose finite sequences.
data Seq a

-- | A set of values <tt>a</tt>.
data Set a

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf2 :: (NFData2 p, NFData a, NFData b) => p a b -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf1 :: (NFData1 f, NFData a) => f a -> ()

-- | Reduce to weak head normal form
--   
--   Equivalent to <tt>\x -&gt; <a>seq</a> x ()</tt>.
--   
--   Useful for defining <a>NFData</a> for types for which NF=WHNF holds.
--   
--   <pre>
--   data T = C1 | C2 | C3
--   instance NFData T where rnf = rwhnf
--   </pre>
rwhnf :: a -> ()

-- | Deeply strict version of <a>&lt;$&gt;</a>.
(<$!!>) :: (Monad m, NFData b) => (a -> b) -> m a -> m b
infixl 4 <$!!>

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | A class of functors that can be fully evaluated.
class NFData1 (f :: Type -> Type)

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return <tt>()</tt>.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: NFData1 f => (a -> ()) -> f a -> ()

-- | A class of bifunctors that can be fully evaluated.
class NFData2 (p :: Type -> Type -> Type)

-- | <a>liftRnf2</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given functions to reduce
--   <tt>a</tt> and <tt>b</tt> arguments respectively, and then return
--   <tt>()</tt>.
--   
--   <b>Note</b>: Unlike for the unary <a>liftRnf</a>, there is currently
--   no support for generically deriving <a>liftRnf2</a>.
liftRnf2 :: NFData2 p => (a -> ()) -> (b -> ()) -> p a b -> ()

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (a, s)

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: forall s (m :: Type -> Type) a. (s -> s) -> StateT s m a -> StateT s m a

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text that is known
--   to be valid.
--   
--   If the input contains any invalid UTF-8 data, an exception will be
--   thrown that cannot be caught in pure code. For more control over the
--   handling of invalid data, use <a>decodeUtf8'</a> or
--   <a>decodeUtf8With</a>.
decodeUtf8 :: ByteString -> Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text
readsTime :: ParseTime t => TimeLocale -> String -> ReadS t
readTime :: ParseTime t => TimeLocale -> String -> String -> t
parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readPTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadP t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readSTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadS t

-- | Parse a time value given a format string. Fails if the input could not
--   be parsed using the given format. See <a>parseTimeM</a> for details.
parseTimeOrError :: ParseTime t => Bool -> TimeLocale -> String -> String -> t

-- | Parses a time value given a format string. Supports the same %-codes
--   as <tt>formatTime</tt>, including <tt>%-</tt>, <tt>%_</tt> and
--   <tt>%0</tt> modifiers, however padding widths are not supported. Case
--   is not significant in the input string. Some variations in the input
--   are accepted:
--   
--   <ul>
--   <li><i><tt>%z</tt></i> accepts any of <tt>±HHMM</tt> or
--   <tt>±HH:MM</tt>.</li>
--   <li><i><tt>%Z</tt></i> accepts any string of letters, or any of the
--   formats accepted by <tt>%z</tt>.</li>
--   <li><i><tt>%0Y</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0G</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0C</tt></i> accepts exactly two digits.</li>
--   <li><i><tt>%0f</tt></i> accepts exactly two digits.</li>
--   </ul>
--   
--   For example, to parse a date in YYYY-MM-DD format, while allowing the
--   month and date to have optional leading zeros (notice the <tt>-</tt>
--   modifier used for <tt>%m</tt> and <tt>%d</tt>):
--   
--   <pre>
--   Prelude Data.Time&gt; parseTimeM True defaultTimeLocale "%Y-%-m-%-d" "2010-3-04" :: Maybe Day
--   Just 2010-03-04
--   </pre>
parseTimeM :: (MonadFail m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t

utcToLocalZonedTime :: UTCTime -> IO ZonedTime
getZonedTime :: IO ZonedTime
zonedTimeToUTC :: ZonedTime -> UTCTime
utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime

-- | A local time together with a time zone.
--   
--   There is no <a>Eq</a> instance for <tt>ZonedTime</tt>. If you want to
--   compare local times, use <a>zonedTimeToLocalTime</a>. If you want to
--   compare absolute times, use <a>zonedTimeToUTC</a>.
data ZonedTime
ZonedTime :: LocalTime -> TimeZone -> ZonedTime
[zonedTimeToLocalTime] :: ZonedTime -> LocalTime
[zonedTimeZone] :: ZonedTime -> TimeZone

-- | Substitute various time-related information for each %-code in the
--   string, as per <a>formatCharacter</a>.
--   
--   The general form is
--   <tt>%&lt;modifier&gt;&lt;width&gt;&lt;alternate&gt;&lt;specifier&gt;</tt>,
--   where <tt>&lt;modifier&gt;</tt>, <tt>&lt;width&gt;</tt>, and
--   <tt>&lt;alternate&gt;</tt> are optional.
--   
--   <h2><tt>&lt;modifier&gt;</tt></h2>
--   
--   glibc-style modifiers can be used before the specifier (here marked as
--   <tt>z</tt>):
--   
--   <ul>
--   <li><i><tt>%-z</tt></i> no padding</li>
--   <li><i><tt>%_z</tt></i> pad with spaces</li>
--   <li><i><tt>%0z</tt></i> pad with zeros</li>
--   <li><i><tt>%^z</tt></i> convert to upper case</li>
--   <li><i><tt>%#z</tt></i> convert to lower case (consistently, unlike
--   glibc)</li>
--   </ul>
--   
--   <h2><tt>&lt;width&gt;</tt></h2>
--   
--   Width digits can also be used after any modifiers and before the
--   specifier (here marked as <tt>z</tt>), for example:
--   
--   <ul>
--   <li><i><tt>%4z</tt></i> pad to 4 characters (with default padding
--   character)</li>
--   <li><i><tt>%_12z</tt></i> pad with spaces to 12 characters</li>
--   </ul>
--   
--   <h2><tt>&lt;alternate&gt;</tt></h2>
--   
--   An optional <tt>E</tt> character indicates an alternate formatting.
--   Currently this only affects <tt>%Z</tt> and <tt>%z</tt>.
--   
--   <ul>
--   <li><i><tt>%Ez</tt></i> alternate formatting</li>
--   </ul>
--   
--   <h2><tt>&lt;specifier&gt;</tt></h2>
--   
--   For all types (note these three are done by <a>formatTime</a>, not by
--   <a>formatCharacter</a>):
--   
--   <ul>
--   <li><i><tt>%%</tt></i> <tt>%</tt></li>
--   <li><i><tt>%t</tt></i> tab</li>
--   <li><i><tt>%n</tt></i> newline</li>
--   </ul>
--   
--   <h3><tt>TimeZone</tt></h3>
--   
--   For <tt>TimeZone</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>):
--   
--   <ul>
--   <li><i><tt>%z</tt></i> timezone offset in the format
--   <tt>±HHMM</tt></li>
--   <li><i><tt>%Ez</tt></i> timezone offset in the format
--   <tt>±HH:MM</tt></li>
--   <li><i><tt>%Z</tt></i> timezone name (or else offset in the format
--   <tt>±HHMM</tt>)</li>
--   <li><i><tt>%EZ</tt></i> timezone name (or else offset in the format
--   <tt>±HH:MM</tt>)</li>
--   </ul>
--   
--   <h3><tt>LocalTime</tt></h3>
--   
--   For <tt>LocalTime</tt> (and <tt>ZonedTime</tt> and <tt>UTCTime</tt>
--   and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%c</tt></i> as <a>dateTimeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%a %b %e %H:%M:%S %Z %Y</tt>)</li>
--   </ul>
--   
--   <h3><tt>TimeOfDay</tt></h3>
--   
--   For <tt>TimeOfDay</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt>
--   and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%R</tt></i> same as <tt>%H:%M</tt></li>
--   <li><i><tt>%T</tt></i> same as <tt>%H:%M:%S</tt></li>
--   <li><i><tt>%X</tt></i> as <a>timeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%H:%M:%S</tt>)</li>
--   <li><i><tt>%r</tt></i> as <a>time12Fmt</a> <tt>locale</tt> (e.g.
--   <tt>%I:%M:%S %p</tt>)</li>
--   <li><i><tt>%P</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), converted to lowercase, <tt>am</tt>,
--   <tt>pm</tt></li>
--   <li><i><tt>%p</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), <tt>AM</tt>, <tt>PM</tt></li>
--   <li><i><tt>%H</tt></i> hour of day (24-hour), 0-padded to two chars,
--   <tt>00</tt> - <tt>23</tt></li>
--   <li><i><tt>%k</tt></i> hour of day (24-hour), space-padded to two
--   chars, <tt> 0</tt> - <tt>23</tt></li>
--   <li><i><tt>%I</tt></i> hour of day-half (12-hour), 0-padded to two
--   chars, <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%l</tt></i> hour of day-half (12-hour), space-padded to two
--   chars, <tt> 1</tt> - <tt>12</tt></li>
--   <li><i><tt>%M</tt></i> minute of hour, 0-padded to two chars,
--   <tt>00</tt> - <tt>59</tt></li>
--   <li><i><tt>%S</tt></i> second of minute (without decimal part),
--   0-padded to two chars, <tt>00</tt> - <tt>60</tt></li>
--   <li><i><tt>%q</tt></i> picosecond of second, 0-padded to twelve chars,
--   <tt>000000000000</tt> - <tt>999999999999</tt>.</li>
--   <li><i><tt>%Q</tt></i> decimal point and fraction of second, up to 12
--   second decimals, without trailing zeros. For a whole number of
--   seconds, <tt>%Q</tt> omits the decimal point unless padding is
--   specified.</li>
--   </ul>
--   
--   <h3><tt>UTCTime</tt> and <tt>ZonedTime</tt></h3>
--   
--   For <tt>UTCTime</tt> and <tt>ZonedTime</tt>:
--   
--   <ul>
--   <li><i><tt>%s</tt></i> number of whole seconds since the Unix epoch.
--   For times before the Unix epoch, this is a negative number. Note that
--   in <tt>%s.%q</tt> and <tt>%s%Q</tt> the decimals are positive, not
--   negative. For example, 0.9 seconds before the Unix epoch is formatted
--   as <tt>-1.1</tt> with <tt>%s%Q</tt>.</li>
--   </ul>
--   
--   <h3><tt>DayOfWeek</tt></h3>
--   
--   For <tt>DayOfWeek</tt> (and <tt>Day</tt> and <tt>LocalTime</tt> and
--   <tt>ZonedTime</tt> and <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%u</tt></i> day of week number for Week Date format,
--   <tt>1</tt> (= Monday) - <tt>7</tt> (= Sunday)</li>
--   <li><i><tt>%w</tt></i> day of week number, <tt>0</tt> (= Sunday) -
--   <tt>6</tt> (= Saturday)</li>
--   <li><i><tt>%a</tt></i> day of week, short form (<a>snd</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt></li>
--   <li><i><tt>%A</tt></i> day of week, long form (<a>fst</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sunday</tt> -
--   <tt>Saturday</tt></li>
--   </ul>
--   
--   <h3><tt>Day</tt></h3>
--   
--   For <tt>Day</tt> (and <tt>LocalTime</tt> and <tt>ZonedTime</tt> and
--   <tt>UTCTime</tt> and <tt>UniversalTime</tt>):
--   
--   <ul>
--   <li><i><tt>%D</tt></i> same as <tt>%m/%d/%y</tt></li>
--   <li><i><tt>%F</tt></i> same as <tt>%Y-%m-%d</tt></li>
--   <li><i><tt>%x</tt></i> as <a>dateFmt</a> <tt>locale</tt> (e.g.
--   <tt>%m/%d/%y</tt>)</li>
--   <li><i><tt>%Y</tt></i> year, no padding. Note <tt>%0Y</tt> and
--   <tt>%_Y</tt> pad to four chars</li>
--   <li><i><tt>%y</tt></i> year of century, 0-padded to two chars,
--   <tt>00</tt> - <tt>99</tt></li>
--   <li><i><tt>%C</tt></i> century, no padding. Note <tt>%0C</tt> and
--   <tt>%_C</tt> pad to two chars</li>
--   <li><i><tt>%B</tt></i> month name, long form (<a>fst</a> from
--   <a>months</a> <tt>locale</tt>), <tt>January</tt> -
--   <tt>December</tt></li>
--   <li><i><tt>%b</tt>, <tt>%h</tt></i> month name, short form (<a>snd</a>
--   from <a>months</a> <tt>locale</tt>), <tt>Jan</tt> - <tt>Dec</tt></li>
--   <li><i><tt>%m</tt></i> month of year, 0-padded to two chars,
--   <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%d</tt></i> day of month, 0-padded to two chars,
--   <tt>01</tt> - <tt>31</tt></li>
--   <li><i><tt>%e</tt></i> day of month, space-padded to two chars, <tt>
--   1</tt> - <tt>31</tt></li>
--   <li><i><tt>%j</tt></i> day of year, 0-padded to three chars,
--   <tt>001</tt> - <tt>366</tt></li>
--   <li><i><tt>%f</tt></i> century for Week Date format, no padding. Note
--   <tt>%0f</tt> and <tt>%_f</tt> pad to two chars</li>
--   <li><i><tt>%V</tt></i> week of year for Week Date format, 0-padded to
--   two chars, <tt>01</tt> - <tt>53</tt></li>
--   <li><i><tt>%U</tt></i> week of year where weeks start on Sunday (as
--   <tt>sundayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   <li><i><tt>%W</tt></i> week of year where weeks start on Monday (as
--   <tt>mondayStartWeek</tt>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   </ul>
--   
--   <h2>Duration types</h2>
--   
--   The specifiers for <tt>DiffTime</tt>, <tt>NominalDiffTime</tt>,
--   <tt>CalendarDiffDays</tt>, and <tt>CalendarDiffTime</tt> are
--   semantically separate from the other types. Specifiers on negative
--   time differences will generally be negative (think <a>rem</a> rather
--   than <a>mod</a>).
--   
--   <h3><tt>NominalDiffTime</tt> and <tt>DiffTime</tt></h3>
--   
--   Note that a "minute" of <tt>DiffTime</tt> is simply 60 SI seconds,
--   rather than a minute of civil time. Use <tt>NominalDiffTime</tt> to
--   work with civil time, ignoring any leap seconds.
--   
--   For <tt>NominalDiffTime</tt> and <tt>DiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%w</tt></i> total whole weeks</li>
--   <li><i><tt>%d</tt></i> total whole days</li>
--   <li><i><tt>%D</tt></i> whole days of week</li>
--   <li><i><tt>%h</tt></i> total whole hours</li>
--   <li><i><tt>%H</tt></i> whole hours of day</li>
--   <li><i><tt>%m</tt></i> total whole minutes</li>
--   <li><i><tt>%M</tt></i> whole minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds</li>
--   <li><i><tt>%Es</tt></i> total seconds, with decimal point and up to
--   &lt;width&gt; (default 12) decimal places, without trailing zeros. For
--   a whole number of seconds, <tt>%Es</tt> omits the decimal point unless
--   padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, with decimal point and
--   &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffDays</tt></h3>
--   
--   For <tt>CalendarDiffDays</tt> (and <tt>CalendarDiffTime</tt>):
--   
--   <ul>
--   <li><i><tt>%y</tt></i> total years</li>
--   <li><i><tt>%b</tt></i> total months</li>
--   <li><i><tt>%B</tt></i> months of year</li>
--   <li><i><tt>%w</tt></i> total weeks, not including months</li>
--   <li><i><tt>%d</tt></i> total days, not including months</li>
--   <li><i><tt>%D</tt></i> days of week</li>
--   </ul>
--   
--   <h3><tt>CalendarDiffTime</tt></h3>
--   
--   For <tt>CalendarDiffTime</tt>:
--   
--   <ul>
--   <li><i><tt>%h</tt></i> total hours, not including months</li>
--   <li><i><tt>%H</tt></i> hours of day</li>
--   <li><i><tt>%m</tt></i> total minutes, not including months</li>
--   <li><i><tt>%M</tt></i> minutes of hour</li>
--   <li><i><tt>%s</tt></i> total whole seconds, not including months</li>
--   <li><i><tt>%Es</tt></i> total seconds, not including months, with
--   decimal point and up to &lt;width&gt; (default 12) decimal places,
--   without trailing zeros. For a whole number of seconds, <tt>%Es</tt>
--   omits the decimal point unless padding is specified.</li>
--   <li><i><tt>%0Es</tt></i> total seconds, not including months, with
--   decimal point and &lt;width&gt; (default 12) decimal places.</li>
--   <li><i><tt>%S</tt></i> whole seconds of minute</li>
--   <li><i><tt>%ES</tt></i> seconds of minute, with decimal point and up
--   to &lt;width&gt; (default 12) decimal places, without trailing zeros.
--   For a whole number of seconds, <tt>%ES</tt> omits the decimal point
--   unless padding is specified.</li>
--   <li><i><tt>%0ES</tt></i> seconds of minute as two digits, with decimal
--   point and &lt;width&gt; (default 12) decimal places.</li>
--   </ul>
formatTime :: FormatTime t => TimeLocale -> String -> t -> String
class FormatTime t

-- | The class of types which can be parsed given a UNIX-style time format
--   string.
class ParseTime t

-- | Format string according to <a>RFC822</a>.
rfc822DateFormat :: String

-- | Construct format string according to <a>ISO-8601</a>.
--   
--   The <tt>Maybe String</tt> argument allows to supply an optional time
--   specification. E.g.:
--   
--   <pre>
--   <a>iso8601DateFormat</a> Nothing            == "%Y-%m-%d"           -- i.e. <tt><i>YYYY-MM-DD</i></tt>
--   <a>iso8601DateFormat</a> (Just "%H:%M:%S")  == "%Y-%m-%dT%H:%M:%S"  -- i.e. <tt><i>YYYY-MM-DD</i>T<i>HH:MM:SS</i></tt>
--   </pre>
iso8601DateFormat :: Maybe String -> String

-- | Locale representing American usage.
--   
--   <a>knownTimeZones</a> contains only the ten time-zones mentioned in
--   RFC 822 sec. 5: "UT", "GMT", "EST", "EDT", "CST", "CDT", "MST", "MDT",
--   "PST", "PDT". Note that the parsing functions will regardless parse
--   "UTC", single-letter military time-zones, and +HHMM format.
defaultTimeLocale :: TimeLocale
data TimeLocale
TimeLocale :: [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> [TimeZone] -> TimeLocale

-- | full and abbreviated week days, starting with Sunday
[wDays] :: TimeLocale -> [(String, String)]

-- | full and abbreviated months
[months] :: TimeLocale -> [(String, String)]

-- | AM/PM symbols
[amPm] :: TimeLocale -> (String, String)

-- | formatting strings
[dateTimeFmt] :: TimeLocale -> String

-- | formatting strings
[dateFmt] :: TimeLocale -> String

-- | formatting strings
[timeFmt] :: TimeLocale -> String

-- | formatting strings
[time12Fmt] :: TimeLocale -> String

-- | time zones known by name
[knownTimeZones] :: TimeLocale -> [TimeZone]

-- | Get the UT1 time of a local time on a particular meridian (in degrees,
--   positive is East).
localTimeToUT1 :: Rational -> LocalTime -> UniversalTime

-- | Get the local time of a UT1 time on a particular meridian (in degrees,
--   positive is East).
ut1ToLocalTime :: Rational -> UniversalTime -> LocalTime

-- | Get the UTC time of a local time in a time zone.
localTimeToUTC :: TimeZone -> LocalTime -> UTCTime

-- | Get the local time of a UTC time in a time zone.
utcToLocalTime :: TimeZone -> UTCTime -> LocalTime

-- | diffLocalTime a b = a - b
diffLocalTime :: LocalTime -> LocalTime -> NominalDiffTime

-- | addLocalTime a b = a + b
addLocalTime :: NominalDiffTime -> LocalTime -> LocalTime

-- | A simple day and time aggregate, where the day is of the specified
--   parameter, and the time is a TimeOfDay. Conversion of this (as local
--   civil time) to UTC depends on the time zone. Conversion of this (as
--   local mean time) to UT1 depends on the longitude.
data LocalTime
LocalTime :: Day -> TimeOfDay -> LocalTime
[localDay] :: LocalTime -> Day
[localTimeOfDay] :: LocalTime -> TimeOfDay

-- | Get the fraction of a day since midnight given a time of day.
timeOfDayToDayFraction :: TimeOfDay -> Rational

-- | Get the time of day given the fraction of a day since midnight.
dayFractionToTimeOfDay :: Rational -> TimeOfDay

-- | Get the time since midnight for a given time of day.
timeOfDayToTime :: TimeOfDay -> DiffTime

-- | Get the time of day given a time since midnight. Time more than 24h
--   will be converted to leap-seconds.
timeToTimeOfDay :: DiffTime -> TimeOfDay

-- | Convert a time of day in some timezone to a time of day in UTC,
--   together with a day adjustment.
localToUTCTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a time of day in UTC to a time of day in some timezone,
--   together with a day adjustment.
utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a count of days and a time of day since midnight into a period
--   of time.
daysAndTimeOfDayToTime :: Integer -> TimeOfDay -> NominalDiffTime

-- | Convert a period of time into a count of days and a time of day since
--   midnight. The time of day will never have a leap second.
timeToDaysAndTimeOfDay :: NominalDiffTime -> (Integer, TimeOfDay)
makeTimeOfDayValid :: Int -> Int -> Pico -> Maybe TimeOfDay

-- | Hour twelve
midday :: TimeOfDay

-- | Hour zero
midnight :: TimeOfDay

-- | Time of day as represented in hour, minute and second (with
--   picoseconds), typically used to express local time of day.
data TimeOfDay
TimeOfDay :: Int -> Int -> Pico -> TimeOfDay

-- | range 0 - 23
[todHour] :: TimeOfDay -> Int

-- | range 0 - 59
[todMin] :: TimeOfDay -> Int

-- | Note that 0 &lt;= <a>todSec</a> &lt; 61, accomodating leap seconds.
--   Any local minute may have a leap second, since leap seconds happen in
--   all zones simultaneously
[todSec] :: TimeOfDay -> Pico

-- | Get the current time-zone.
getCurrentTimeZone :: IO TimeZone

-- | Get the local time-zone for a given time (varying as per summertime
--   adjustments).
getTimeZone :: UTCTime -> IO TimeZone

-- | The UTC time zone.
utc :: TimeZone

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime).
timeZoneOffsetString :: TimeZone -> String

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime), with arbitrary padding.
timeZoneOffsetString' :: Maybe Char -> TimeZone -> String

-- | Create a nameless non-summer timezone for this number of hours.
hoursToTimeZone :: Int -> TimeZone

-- | Create a nameless non-summer timezone for this number of minutes.
minutesToTimeZone :: Int -> TimeZone

-- | A TimeZone is a whole number of minutes offset from UTC, together with
--   a name and a "just for summer" flag.
data TimeZone
TimeZone :: Int -> Bool -> String -> TimeZone

-- | The number of minutes offset from UTC. Positive means local time will
--   be later in the day than UTC.
[timeZoneMinutes] :: TimeZone -> Int

-- | Is this time zone just persisting for the summer?
[timeZoneSummerOnly] :: TimeZone -> Bool

-- | The name of the zone, typically a three- or four-letter acronym.
[timeZoneName] :: TimeZone -> String

-- | Scale by a factor. Note that <tt>scaleCalendarDiffTime (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffTime :: Integer -> CalendarDiffTime -> CalendarDiffTime
calendarTimeTime :: NominalDiffTime -> CalendarDiffTime
calendarTimeDays :: CalendarDiffDays -> CalendarDiffTime
data CalendarDiffTime
CalendarDiffTime :: Integer -> NominalDiffTime -> CalendarDiffTime
[ctMonths] :: CalendarDiffTime -> Integer
[ctTime] :: CalendarDiffTime -> NominalDiffTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | Get the current <a>UTCTime</a> from the system clock.
getCurrentTime :: IO UTCTime

-- | The Modified Julian Date is the day with the fraction of the day,
--   measured from UT midnight. It's used to represent UT1, which is time
--   as measured by the earth's rotation, adjusted for various wobbles.
newtype UniversalTime
ModJulianDate :: Rational -> UniversalTime
[getModJulianDate] :: UniversalTime -> Rational

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime
UTCTime :: Day -> DiffTime -> UTCTime

-- | the day
[utctDay] :: UTCTime -> Day

-- | the time from midnight, 0 &lt;= t &lt; 86401s (because of
--   leap-seconds)
[utctDayTime] :: UTCTime -> DiffTime

-- | The resolution of <a>getSystemTime</a>, <tt>getCurrentTime</tt>,
--   <tt>getPOSIXTime</tt>
getTime_resolution :: DiffTime

-- | One day in <a>NominalDiffTime</a>.
nominalDay :: NominalDiffTime

-- | Get the seconds in a <a>NominalDiffTime</a>.
nominalDiffTimeToSeconds :: NominalDiffTime -> Pico

-- | Create a <a>NominalDiffTime</a> from a number of seconds.
secondsToNominalDiffTime :: Pico -> NominalDiffTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions will treat it as seconds. For example, <tt>(0.010
--   :: NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data NominalDiffTime

-- | Get the number of picoseconds in a <a>DiffTime</a>.
diffTimeToPicoseconds :: DiffTime -> Integer

-- | Create a <a>DiffTime</a> from a number of picoseconds.
picosecondsToDiffTime :: Integer -> DiffTime

-- | Create a <a>DiffTime</a> which represents an integral number of
--   seconds.
secondsToDiffTime :: Integer -> DiffTime

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime
dayOfWeek :: Day -> DayOfWeek
data DayOfWeek
Monday :: DayOfWeek
Tuesday :: DayOfWeek
Wednesday :: DayOfWeek
Thursday :: DayOfWeek
Friday :: DayOfWeek
Saturday :: DayOfWeek
Sunday :: DayOfWeek

-- | Calendrical difference, with as many whole months as possible. Same as
--   <a>diffGregorianDurationClip</a> for positive durations.
diffGregorianDurationRollOver :: Day -> Day -> CalendarDiffDays

-- | Calendrical difference, with as many whole months as possible
diffGregorianDurationClip :: Day -> Day -> CalendarDiffDays

-- | Add months (rolling over to next month), then add days
addGregorianDurationRollOver :: CalendarDiffDays -> Day -> Day

-- | Add months (clipped to last day), then add days
addGregorianDurationClip :: CalendarDiffDays -> Day -> Day

-- | Add years, matching month and day, with Feb 29th rolled over to Mar
--   1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.
addGregorianYearsRollOver :: Integer -> Day -> Day

-- | Add years, matching month and day, with Feb 29th clipped to Feb 28th
--   if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.
addGregorianYearsClip :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month rolling over to
--   the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.
addGregorianMonthsRollOver :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month clipped to the
--   last day. For instance, 2005-01-30 + 1 month = 2005-02-28.
addGregorianMonthsClip :: Integer -> Day -> Day

-- | The number of days in a given month according to the proleptic
--   Gregorian calendar. First argument is year, second is month.
gregorianMonthLength :: Integer -> Int -> Int

-- | Show in ISO 8601 format (yyyy-mm-dd)
showGregorian :: Day -> String

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will
--   return Nothing
fromGregorianValid :: Integer -> Int -> Int -> Maybe Day

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will be
--   clipped to the correct range, month first, then day.
fromGregorian :: Integer -> Int -> Int -> Day

-- | Convert to proleptic Gregorian calendar. First element of result is
--   year, second month number (1-12), third day (1-31).
toGregorian :: Day -> (Integer, Int, Int)

-- | Is this year a leap year according to the proleptic Gregorian
--   calendar?
isLeapYear :: Integer -> Bool
diffDays :: Day -> Day -> Integer
addDays :: Integer -> Day -> Day
pattern ModifiedJulianDay :: () => Integer -> Day
toModifiedJulianDay :: Day -> Integer

-- | Scale by a factor. Note that <tt>scaleCalendarDiffDays (-1)</tt> will
--   not perfectly invert a duration, due to variable month lengths.
scaleCalendarDiffDays :: Integer -> CalendarDiffDays -> CalendarDiffDays
calendarYear :: CalendarDiffDays
calendarMonth :: CalendarDiffDays
calendarWeek :: CalendarDiffDays
calendarDay :: CalendarDiffDays
data CalendarDiffDays
CalendarDiffDays :: Integer -> Integer -> CalendarDiffDays
[cdMonths] :: CalendarDiffDays -> Integer
[cdDays] :: CalendarDiffDays -> Integer
data Finite (n :: Nat)
finites :: forall (n :: Nat). KnownNat n => [Finite n]
modulo :: forall (n :: Nat). KnownNat n => Integer -> Finite n
packFinite :: forall (n :: Nat). KnownNat n => Integer -> Maybe (Finite n)
getFinite :: forall (n :: Nat). Finite n -> Integer
class Profunctor (p :: Type -> Type -> Type)
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c
class (Foldable1 t, Traversable t) => Traversable1 (t :: Type -> Type)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)
ixAt :: At m => Index m -> Traversal' m (IxValue m)
sans :: At m => Index m -> m -> m
pattern (:<) :: Cons b b a a => a -> b -> b
pattern (:>) :: Snoc a a b b => a -> b -> a
(<|) :: Cons s s a a => a -> s -> s
_head :: Cons s s a a => Traversal' s a
_init :: Snoc s s a a => Traversal' s s
_last :: Snoc s s a a => Traversal' s a
_tail :: Cons s s a a => Traversal' s s
cons :: Cons s s a a => a -> s -> s
snoc :: Snoc s s a a => s -> a -> s
unsnoc :: Snoc s s a a => s -> Maybe (s, a)
(|>) :: Snoc s s a a => s -> a -> s
pattern Empty :: AsEmpty s => s
cloneEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2). AnEquality s t a b -> Equality s t a b
equality :: forall k1 k2 (s :: k1) (a :: k1) (b :: k2) (t :: k2). (s :~: a) -> (b :~: t) -> Equality s t a b
equality' :: forall k2 (a :: k2) (b :: k2). (a :~: b) -> Equality' a b
fromEq :: forall k2 k1 (s :: k2) (t :: k1) (a :: k2) (b :: k1). AnEquality s t a b -> Equality b a t s
fromLeibniz :: forall k1 k2 (a :: k1) (b :: k2) (s :: k1) (t :: k2). (Identical a b a b -> Identical a b s t) -> Equality s t a b
fromLeibniz' :: forall k2 (s :: k2) (a :: k2). ((s :~: s) -> s :~: a) -> Equality' s a
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) f. AnEquality s t a b -> f s -> f a
overEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) p. AnEquality s t a b -> p a b -> p s t
runEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2). AnEquality s t a b -> Identical s t a b
simple :: forall k2 (a :: k2). Equality' a a
simply :: forall k1 k2 p (f :: k1 -> k2) (s :: k1) (a :: k1) (rep :: RuntimeRep) (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r
substEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (rep :: RuntimeRep) (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r
underEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) p. AnEquality s t a b -> p t s -> p b a
withEquality :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (rep :: RuntimeRep) (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r
(^..) :: s -> Getting (Endo [a]) s a -> [a]
(^?) :: s -> Getting (First a) s a -> Maybe a
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool
andOf :: Getting All s Bool -> s -> Bool
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]
concatOf :: Getting [r] s [r] -> s -> [r]
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a
first1Of :: Getting (First a) s a -> s -> a
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r
foldMapOf :: Getting r s a -> (a -> r) -> s -> r
foldOf :: Getting a s a -> s -> a
folded :: forall (f :: Type -> Type) a. Foldable f => IndexedFold Int (f a) a
folded64 :: forall (f :: Type -> Type) a. Foldable f => IndexedFold Int64 (f a) a
folding :: Foldable f => (s -> f a) -> Fold s a
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()
has :: Getting Any s a -> s -> Bool
hasn't :: Getting All s a -> s -> Bool
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s)) :: Type -> Type) s a -> Optical' p q f s a
iterated :: Apply f => (a -> a) -> LensLike' f a a
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()
last1Of :: Getting (Last a) s a -> s -> a
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int
lined :: forall (f :: Type -> Type). Applicative f => IndexedLensLike' Int f String String
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool
notNullOf :: Getting Any s a -> s -> Bool
nullOf :: Getting All s a -> s -> Bool
orOf :: Getting Any s Bool -> s -> Bool
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
repeated :: Apply f => LensLike' f a a
replicated :: Int -> Fold a a
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a
toListOf :: Getting (Endo [a]) s a -> s -> [a]
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()
unfolded :: (b -> Maybe (a, b)) -> Fold b a
worded :: forall (f :: Type -> Type). Applicative f => IndexedLensLike' Int f String String
(^.) :: s -> Getting a s a -> a
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
use :: MonadState s m => Getting a s a -> m a
uses :: MonadState s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r
view :: MonadReader s m => Getting a s a -> m a
views :: MonadReader s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
itoList :: FoldableWithIndex i f => f a -> [(i, a)]
itraverseBy :: TraversableWithIndex i t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()
none :: Foldable f => (a -> Bool) -> f a -> Bool
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r
selfIndex :: Indexable a p => p a fb -> a -> fb
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)
makeClassyPrisms :: Name -> DecsQ
makePrisms :: Name -> DecsQ
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
pattern Lazy :: Strict t s => t -> s
pattern List :: IsList l => [Item l] -> l
pattern Reversed :: Reversing t => t -> t
pattern Strict :: Strict s t => t -> s
pattern Swapped :: forall p c d. Swapped p => p d c -> p c d
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a
bimapping :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b s' t' a' b'. (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')
cloneIso :: AnIso s t a b -> Iso s t a b
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b
contramapping :: forall (f :: Type -> Type) s t a b. Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)
dimapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b s' t' a' b'. (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')
enum :: Enum a => Iso' Int a
firsting :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b x y. (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')
from :: AnIso s t a b -> Iso b a t s
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)
involuted :: (a -> a) -> Iso' a a
iso :: (s -> a) -> (b -> t) -> Iso s t a b
lazy :: Strict lazy strict => Iso' strict lazy
lmapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b x y. (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)
mapping :: forall (f :: Type -> Type) (g :: Type -> Type) s t a b. (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)
non :: Eq a => a -> Iso' (Maybe a) a
non' :: APrism' a () -> Iso' (Maybe a) a
reversed :: Reversing a => Iso' a a
rmapping :: forall (p :: Type -> Type -> Type) (q :: Type -> Type -> Type) s t a b x y. (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)
seconding :: forall (f :: Type -> Type -> Type) (g :: Type -> Type -> Type) s t a b x y. (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)
under :: AnIso s t a b -> (t -> s) -> b -> a
withIso :: forall s t a b (rep :: RuntimeRep) (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
xplat :: forall k s g (t :: k) a (b :: k). Optic (Costar ((->) s :: Type -> Type)) g s t a b -> ((s -> a) -> g b) -> g t
xplatf :: forall k f g s (t :: k) a (b :: k). Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
(#~) :: ALens s t a b -> b -> s -> t
(%%=) :: forall k s m p r (a :: k) b. MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
(%%@~) :: forall k i f s (t :: k) a (b :: k). Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
(%%~) :: forall k f s (t :: k) a (b :: k). LensLike f s t a b -> (a -> f b) -> s -> f t
(&~) :: s -> State s a -> s
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
(<#~) :: ALens s t a b -> b -> s -> (b, t)
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r
(<<<>~) :: Monoid r => LensLike' ((,) r) s r -> r -> s -> (r, s)
(<<>=) :: (MonadState s m, Monoid r) => LensLike' ((,) r) s r -> r -> m r
(<<>~) :: Monoid m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(??) :: Functor f => f (a -> b) -> a -> f b
(^#) :: s -> ALens s t a b -> a
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
chosen :: IndexPreservingLens (Either a a) (Either b b) a b
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b
cloneLens :: ALens s t a b -> Lens s t a b
devoid :: forall k p f (a :: k) b. Over p f Void Void a b
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b
head1 :: forall (t :: Type -> Type) a. Traversable1 t => Lens' (t a) a
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b
inside :: forall (p :: Type -> Type -> Type) s t a b e. Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b
last1 :: forall (t :: Type -> Type) a. Traversable1 t => Lens' (t a) a
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
locus :: forall (p :: Type -> Type -> Type -> Type) a c s b. IndexedComonadStore p => Lens (p a c s) (p b c s) a b
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t
storing :: ALens s t a b -> b -> s -> t
united :: Lens' a ()
withLens :: forall s t a b (rep :: RuntimeRep) (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r
ilevels :: forall (f :: Type -> Type) i s t a b j. Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)
levels :: forall (f :: Type -> Type) s t a b. Applicative f => Traversing ((->) :: Type -> Type -> Type) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)
(...) :: forall k f c s t p (a :: k) b. (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
children :: Plated a => a -> [a]
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b
contexts :: Plated a => a -> [Context a a a]
contextsOf :: ATraversal' a a -> a -> [Context a a a]
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]
cosmos :: Plated a => Fold a a
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a
gplate1 :: forall k (f :: k -> Type) (a :: k). (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)
holes :: Plated a => a -> [Pretext ((->) :: Type -> Type -> Type) a a a]
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]
para :: Plated a => (a -> [r] -> r) -> a -> r
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r
parts :: Plated a => Lens' a [a]
rewrite :: Plated a => (a -> Maybe a) -> a -> a
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t
transform :: Plated a => (a -> a) -> a -> a
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t
transformOf :: ASetter a b a b -> (b -> b) -> a -> b
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t
universe :: Plated a => a -> [a]
universeOf :: Getting [a] a a -> a -> [a]
universeOn :: Plated a => Getting [a] s a -> s -> [a]
universeOnOf :: Getting [a] s a -> Getting [a] a a -> s -> [a]
_Just :: Prism (Maybe a) (Maybe b) a b
_Left :: Prism (Either a c) (Either b c) a b
_Nothing :: Prism' (Maybe a) ()
_Right :: Prism (Either c a) (Either c b) a b
_Show :: (Read a, Show a) => Prism' String a
_Void :: Prism s s a Void
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)
below :: forall (f :: Type -> Type) s a. Traversable f => APrism' s a -> Prism' (f s) (f a)
clonePrism :: APrism s t a b -> Prism s t a b
isn't :: APrism s t a b -> s -> Bool
matching :: APrism s t a b -> s -> Either t a
nearly :: a -> (a -> Bool) -> Prism' a ()
only :: Eq a => a -> Prism' a ()
outside :: forall (p :: Type -> Type -> Type) s t a b r. Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)
(#) :: AReview t b -> b -> t
re :: AReview t b -> Getter b t
reuse :: MonadState b m => AReview t b -> m t
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r
review :: MonadReader b m => AReview t b -> m t
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(*~) :: Num a => ASetter s t a a -> a -> s -> t
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(+~) :: Num a => ASetter s t a a -> a -> s -> t
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(-~) :: Num a => ASetter s t a a -> a -> s -> t
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
(.~) :: ASetter s t a b -> b -> s -> t
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
(<>=) :: (MonadState s m, Monoid a) => ASetter' s a -> a -> m ()
(<>~) :: Monoid a => ASetter s t a a -> a -> s -> t
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
argument :: forall (p :: Type -> Type -> Type) b r a. Profunctor p => Setter (p b r) (p a r) a b
assign :: MonadState s m => ASetter s s a b -> b -> m ()
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b
cloneSetter :: ASetter s t a b -> Setter s t a b
contramapped :: forall (f :: Type -> Type) b a. Contravariant f => Setter (f b) (f a) a b
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b
lifted :: forall (m :: Type -> Type) a b. Monad m => Setter (m a) (m b) a b
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r
mapOf :: ASetter s t a b -> (a -> b) -> s -> t
mapped :: forall (f :: Type -> Type) a b. Functor f => Setter (f a) (f b) a b
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
over :: ASetter s t a b -> (a -> b) -> s -> t
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()
set :: ASetter s t a b -> b -> s -> t
set' :: ASetter' s a -> a -> s -> s
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
abbreviatedFields :: LensRules
abbreviatedNamer :: FieldNamer
camelCaseFields :: LensRules
camelCaseNamer :: FieldNamer
classUnderscoreNoPrefixFields :: LensRules
classUnderscoreNoPrefixNamer :: FieldNamer
classyRules :: LensRules
classyRules_ :: LensRules
createClass :: Lens' LensRules Bool
declareClassy :: DecsQ -> DecsQ
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ
declareFields :: DecsQ -> DecsQ
declareLenses :: DecsQ -> DecsQ
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ
declareLensesWith :: LensRules -> DecsQ -> DecsQ
declarePrisms :: DecsQ -> DecsQ
declareWrapped :: DecsQ -> DecsQ
defaultFieldRules :: LensRules
generateLazyPatterns :: Lens' LensRules Bool
generateSignatures :: Lens' LensRules Bool
generateUpdateableOptics :: Lens' LensRules Bool
lensClass :: Lens' LensRules ClassyNamer
lensField :: Lens' LensRules FieldNamer
lensRules :: LensRules
lensRulesFor :: [(String, String)] -> LensRules
lookingupNamer :: [(String, String)] -> FieldNamer
makeClassy :: Name -> DecsQ
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ
makeClassy_ :: Name -> DecsQ
makeFields :: Name -> DecsQ
makeFieldsNoPrefix :: Name -> DecsQ
makeLenses :: Name -> DecsQ
makeLensesFor :: [(String, String)] -> Name -> DecsQ
makeLensesWith :: LensRules -> Name -> DecsQ
makeWrapped :: Name -> DecsQ
mappingNamer :: (String -> [String]) -> FieldNamer
simpleLenses :: Lens' LensRules Bool
underscoreFields :: LensRules
underscoreNamer :: FieldNamer
underscoreNoPrefixNamer :: FieldNamer
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b
both :: forall (r :: Type -> Type -> Type) a b. Bitraversable r => Traversal (r a a) (r b b) a b
both1 :: forall (r :: Type -> Type -> Type) a b. Bitraversable1 r => Traversal1 (r a a) (r b b) a b
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b
cloneTraversal :: ATraversal s t a b -> Traversal s t a b
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a
element :: forall (t :: Type -> Type) a. Traversable t => Int -> IndexedTraversal' Int (t a) a
elementOf :: forall (f :: Type -> Type) s t a. Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a
elements :: forall (t :: Type -> Type) a. Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a
elementsOf :: forall (f :: Type -> Type) s t a. Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t
ignored :: Applicative f => pafb -> s -> f s
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t
ipartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t
iunsafePartsOf :: (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]
loci :: Traversal (Bazaar ((->) :: Type -> Type -> Type) a c s) (Bazaar ((->) :: Type -> Type -> Type) b c s) a b
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
partsOf :: Functor f => Traversing ((->) :: Type -> Type -> Type) f s t a a -> LensLike f s t [a] [a]
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t
sequenceAOf :: LensLike f s t (f b) b -> s -> f t
sequenceByOf :: Traversal s t (f b) b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> s -> f t
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]
traverseByOf :: Traversal s t a b -> (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t
traversed :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int (f a) (f b) a b
traversed1 :: forall (f :: Type -> Type) a b. Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b
traversed64 :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int64 (f a) (f b) a b
unsafePartsOf :: Functor f => Traversing ((->) :: Type -> Type -> Type) f s t a b -> LensLike f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b
_1' :: Field1 s t a b => Lens s t a b
_10' :: Field10 s t a b => Lens s t a b
_11' :: Field11 s t a b => Lens s t a b
_12' :: Field12 s t a b => Lens s t a b
_13' :: Field13 s t a b => Lens s t a b
_14' :: Field14 s t a b => Lens s t a b
_15' :: Field15 s t a b => Lens s t a b
_16' :: Field16 s t a b => Lens s t a b
_17' :: Field17 s t a b => Lens s t a b
_18' :: Field18 s t a b => Lens s t a b
_19' :: Field19 s t a b => Lens s t a b
_2' :: Field2 s t a b => Lens s t a b
_3' :: Field3 s t a b => Lens s t a b
_4' :: Field4 s t a b => Lens s t a b
_5' :: Field5 s t a b => Lens s t a b
_6' :: Field6 s t a b => Lens s t a b
_7' :: Field7 s t a b => Lens s t a b
_8' :: Field8 s t a b => Lens s t a b
_9' :: Field9 s t a b => Lens s t a b
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
_GWrapped' :: forall s (d :: Meta) (c :: Meta) (s' :: Meta) a. (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)
class Ixed m => At m
at :: At m => Index m -> Lens' m (Maybe (IxValue m))
class Contains m
contains :: Contains m => Index m -> Lens' m Bool
type family Index s
type family IxValue m
class Ixed m
ix :: Ixed m => Index m -> Traversal' m (IxValue m)
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s
each :: Each s t a b => Traversal s t a b
class AsEmpty a
_Empty :: AsEmpty a => Prism' a ()
type AnEquality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = Identical a Proxy b a Proxy b -> Identical a Proxy b s Proxy t
type AnEquality' (s :: k2) (a :: k2) = AnEquality s s a a
data Identical (a :: k) (b :: k1) (s :: k) (t :: k1)
[Identical] :: forall k k1 (a :: k) (b :: k1). Identical a b a b
type Accessing (p :: Type -> Type -> Type) m s a = p a Const m a -> s -> Const m s
type Getting r s a = a -> Const r a -> s -> Const r s
type IndexedGetting i m s a = Indexed i a Const m a -> s -> Const m s
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b
newtype Bazaar (p :: Type -> Type -> Type) a b t
Bazaar :: (forall (f :: Type -> Type). Applicative f => p a (f b) -> f t) -> Bazaar (p :: Type -> Type -> Type) a b t
[runBazaar] :: Bazaar (p :: Type -> Type -> Type) a b t -> forall (f :: Type -> Type). Applicative f => p a (f b) -> f t
type Bazaar' (p :: Type -> Type -> Type) a = Bazaar p a a
newtype Bazaar1 (p :: Type -> Type -> Type) a b t
Bazaar1 :: (forall (f :: Type -> Type). Apply f => p a (f b) -> f t) -> Bazaar1 (p :: Type -> Type -> Type) a b t
[runBazaar1] :: Bazaar1 (p :: Type -> Type -> Type) a b t -> forall (f :: Type -> Type). Apply f => p a (f b) -> f t
type Bazaar1' (p :: Type -> Type -> Type) a = Bazaar1 p a a
data Context a b t
Context :: (b -> t) -> a -> Context a b t
type Context' a = Context a a
type ClassyNamer = Name -> Maybe (Name, Name)
data DefName
TopName :: Name -> DefName
MethodName :: Name -> Name -> DefName
type FieldNamer = Name -> [Name] -> Name -> [DefName]
data LensRules
data Leftmost a
data Rightmost a
data Sequenced a (m :: Type -> Type)
data Traversed a (f :: Type -> Type)
class (Choice p, Corepresentable p, Comonad Corep p, Traversable Corep p, Strong p, Representable p, Monad Rep p, MonadFix Rep p, Distributive Rep p, Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p) => Conjoined (p :: Type -> Type -> Type)
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)
conjoined :: Conjoined p => (p ~ ((->) :: Type -> Type -> Type) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
class Conjoined p => Indexable i (p :: Type -> Type -> Type)
indexed :: Indexable i p => p a b -> i -> a -> b
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
[runIndexed] :: Indexed i a b -> i -> a -> b
class Reversing t
reversing :: Reversing t => t -> t
data Level i a
data Magma i t b a
class (Profunctor p, Bifunctor p) => Reviewable (p :: Type -> Type -> Type)
class (Applicative f, Distributive f, Traversable f) => Settable (f :: Type -> Type)
type AnIso s t a b = Exchange a b a Identity b -> Exchange a b s Identity t
type AnIso' s a = AnIso s s a a
class Strict lazy strict | lazy -> strict, strict -> lazy
strict :: Strict lazy strict => Iso' lazy strict
class Bifunctor p => Swapped (p :: Type -> Type -> Type)
swapped :: Swapped p => Iso (p a b) (p c d) (p b a) (p d c)
type ALens s t a b = LensLike Pretext (->) :: Type -> Type -> Type a b s t a b
type ALens' s a = ALens s s a a
type AnIndexedLens i s t a b = Optical Indexed i (->) :: Type -> Type -> Type Pretext Indexed i a b s t a b
type AnIndexedLens' i s a = AnIndexedLens i s s a a
class GPlated a (g :: k -> Type)
class GPlated1 (f :: k -> Type) (g :: k -> Type)
class Plated a
plate :: Plated a => Traversal' a a
type APrism s t a b = Market a b a Identity b -> Market a b s Identity t
type APrism' s a = APrism s s a a
newtype ReifiedFold s a
Fold :: Fold s a -> ReifiedFold s a
[runFold] :: ReifiedFold s a -> Fold s a
newtype ReifiedGetter s a
Getter :: Getter s a -> ReifiedGetter s a
[runGetter] :: ReifiedGetter s a -> Getter s a
newtype ReifiedIndexedFold i s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
[runIndexedFold] :: ReifiedIndexedFold i s a -> IndexedFold i s a
newtype ReifiedIndexedGetter i s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
[runIndexedGetter] :: ReifiedIndexedGetter i s a -> IndexedGetter i s a
newtype ReifiedIndexedLens i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
[runIndexedLens] :: ReifiedIndexedLens i s t a b -> IndexedLens i s t a b
type ReifiedIndexedLens' i s a = ReifiedIndexedLens i s s a a
newtype ReifiedIndexedSetter i s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
[runIndexedSetter] :: ReifiedIndexedSetter i s t a b -> IndexedSetter i s t a b
type ReifiedIndexedSetter' i s a = ReifiedIndexedSetter i s s a a
newtype ReifiedIndexedTraversal i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
[runIndexedTraversal] :: ReifiedIndexedTraversal i s t a b -> IndexedTraversal i s t a b
type ReifiedIndexedTraversal' i s a = ReifiedIndexedTraversal i s s a a
newtype ReifiedIso s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
[runIso] :: ReifiedIso s t a b -> Iso s t a b
type ReifiedIso' s a = ReifiedIso s s a a
newtype ReifiedLens s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
[runLens] :: ReifiedLens s t a b -> Lens s t a b
type ReifiedLens' s a = ReifiedLens s s a a
newtype ReifiedPrism s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
[runPrism] :: ReifiedPrism s t a b -> Prism s t a b
type ReifiedPrism' s a = ReifiedPrism s s a a
newtype ReifiedSetter s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
[runSetter] :: ReifiedSetter s t a b -> Setter s t a b
type ReifiedSetter' s a = ReifiedSetter s s a a
newtype ReifiedTraversal s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
[runTraversal] :: ReifiedTraversal s t a b -> Traversal s t a b
type ReifiedTraversal' s a = ReifiedTraversal s s a a
type ASetter s t a b = a -> Identity b -> s -> Identity t
type ASetter' s a = ASetter s s a a
type AnIndexedSetter i s t a b = Indexed i a Identity b -> s -> Identity t
type AnIndexedSetter' i s a = AnIndexedSetter i s s a a
type Setting (p :: Type -> Type -> Type) s t a b = p a Identity b -> s -> Identity t
type Setting' (p :: Type -> Type -> Type) s a = Setting p s s a a
type ATraversal s t a b = LensLike Bazaar (->) :: Type -> Type -> Type a b s t a b
type ATraversal' s a = ATraversal s s a a
type ATraversal1 s t a b = LensLike Bazaar1 (->) :: Type -> Type -> Type a b s t a b
type ATraversal1' s a = ATraversal1 s s a a
type AnIndexedTraversal i s t a b = Over Indexed i Bazaar Indexed i a b s t a b
type AnIndexedTraversal' i s a = AnIndexedTraversal i s s a a
type AnIndexedTraversal1 i s t a b = Over Indexed i Bazaar1 Indexed i a b s t a b
type AnIndexedTraversal1' i s a = AnIndexedTraversal1 i s s a a
class Ord k => TraverseMax k (m :: Type -> Type) | m -> k
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v
class Ord k => TraverseMin k (m :: Type -> Type) | m -> k
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v
type Traversing (p :: Type -> Type -> Type) (f :: Type -> Type) s t a b = Over p BazaarT p f a b s t a b
type Traversing' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Traversing p f s s a a
type Traversing1 (p :: Type -> Type -> Type) (f :: Type -> Type) s t a b = Over p BazaarT1 p f a b s t a b
type Traversing1' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Traversing1 p f s s a a
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s
_1 :: Field1 s t a b => Lens s t a b
class Field10 s t a b | s -> a, t -> b, s b -> t, t a -> s
_10 :: Field10 s t a b => Lens s t a b
class Field11 s t a b | s -> a, t -> b, s b -> t, t a -> s
_11 :: Field11 s t a b => Lens s t a b
class Field12 s t a b | s -> a, t -> b, s b -> t, t a -> s
_12 :: Field12 s t a b => Lens s t a b
class Field13 s t a b | s -> a, t -> b, s b -> t, t a -> s
_13 :: Field13 s t a b => Lens s t a b
class Field14 s t a b | s -> a, t -> b, s b -> t, t a -> s
_14 :: Field14 s t a b => Lens s t a b
class Field15 s t a b | s -> a, t -> b, s b -> t, t a -> s
_15 :: Field15 s t a b => Lens s t a b
class Field16 s t a b | s -> a, t -> b, s b -> t, t a -> s
_16 :: Field16 s t a b => Lens s t a b
class Field17 s t a b | s -> a, t -> b, s b -> t, t a -> s
_17 :: Field17 s t a b => Lens s t a b
class Field18 s t a b | s -> a, t -> b, s b -> t, t a -> s
_18 :: Field18 s t a b => Lens s t a b
class Field19 s t a b | s -> a, t -> b, s b -> t, t a -> s
_19 :: Field19 s t a b => Lens s t a b
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s
_2 :: Field2 s t a b => Lens s t a b
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s
_3 :: Field3 s t a b => Lens s t a b
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s
_4 :: Field4 s t a b => Lens s t a b
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s
_5 :: Field5 s t a b => Lens s t a b
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s
_6 :: Field6 s t a b => Lens s t a b
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s
_7 :: Field7 s t a b => Lens s t a b
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s
_8 :: Field8 s t a b => Lens s t a b
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s
_9 :: Field9 s t a b => Lens s t a b
type AReview t b = Optic' Tagged :: Type -> Type -> Type Identity t b
type As (a :: k2) = Equality' a a
type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall k3 (p :: k1 -> k3 -> Type) (f :: k2 -> k3). () => p a f b -> p s f t
type Equality' (s :: k2) (a :: k2) = Equality s s a a
type Fold s a = forall (f :: Type -> Type). (Contravariant f, Applicative f) => a -> f a -> s -> f s
type Fold1 s a = forall (f :: Type -> Type). (Contravariant f, Apply f) => a -> f a -> s -> f s
type Getter s a = forall (f :: Type -> Type). (Contravariant f, Functor f) => a -> f a -> s -> f s
type IndexPreservingFold s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Applicative f) => p a f a -> p s f s
type IndexPreservingFold1 s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Apply f) => p a f a -> p s f s
type IndexPreservingGetter s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Contravariant f, Functor f) => p a f a -> p s f s
type IndexPreservingLens s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Functor f) => p a f b -> p s f t
type IndexPreservingLens' s a = IndexPreservingLens s s a a
type IndexPreservingSetter s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Settable f) => p a f b -> p s f t
type IndexPreservingSetter' s a = IndexPreservingSetter s s a a
type IndexPreservingTraversal s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Applicative f) => p a f b -> p s f t
type IndexPreservingTraversal' s a = IndexPreservingTraversal s s a a
type IndexPreservingTraversal1 s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Conjoined p, Apply f) => p a f b -> p s f t
type IndexPreservingTraversal1' s a = IndexPreservingTraversal1 s s a a
type IndexedFold i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Applicative f) => p a f a -> s -> f s
type IndexedFold1 i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Apply f) => p a f a -> s -> f s
type IndexedGetter i s a = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Contravariant f, Functor f) => p a f a -> s -> f s
type IndexedLens i s t a b = forall (f :: Type -> Type) (p :: Type -> Type -> Type). (Indexable i p, Functor f) => p a f b -> s -> f t
type IndexedLens' i s a = IndexedLens i s s a a
type IndexedLensLike i (f :: k -> Type) s (t :: k) a (b :: k) = forall (p :: Type -> Type -> Type). Indexable i p => p a f b -> s -> f t
type IndexedLensLike' i (f :: Type -> Type) s a = IndexedLensLike i f s s a a
type IndexedSetter i s t a b = forall (f :: Type -> Type) (p :: Type -> Type -> Type). (Indexable i p, Settable f) => p a f b -> s -> f t
type IndexedSetter' i s a = IndexedSetter i s s a a
type IndexedTraversal i s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Applicative f) => p a f b -> s -> f t
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Indexable i p, Apply f) => p a f b -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a
type Iso s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Profunctor p, Functor f) => p a f b -> p s f t
type Iso' s a = Iso s s a a
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t
type Lens' s a = Lens s s a a
type LensLike (f :: k -> Type) s (t :: k) a (b :: k) = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = LensLike f s s a a
type Optic (p :: k -> k1 -> Type) (f :: k2 -> k1) (s :: k) (t :: k2) (a :: k) (b :: k2) = p a f b -> p s f t
type Optic' (p :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optic p f s s a a
type Optical (p :: k -> k1 -> Type) (q :: k2 -> k1 -> Type) (f :: k3 -> k1) (s :: k2) (t :: k3) (a :: k) (b :: k3) = p a f b -> q s f t
type Optical' (p :: k -> k1 -> Type) (q :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optical p q f s s a a
type Over (p :: k -> Type -> Type) (f :: k1 -> Type) s (t :: k1) (a :: k) (b :: k1) = p a f b -> s -> f t
type Over' (p :: Type -> Type -> Type) (f :: Type -> Type) s a = Over p f s s a a
type Prism s t a b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Choice p, Applicative f) => p a f b -> p s f t
type Prism' s a = Prism s s a a
type Review t b = forall (p :: Type -> Type -> Type) (f :: Type -> Type). (Choice p, Bifunctor p, Settable f) => Optic' p f t b
type Setter s t a b = forall (f :: Type -> Type). Settable f => a -> f b -> s -> f t
type Setter' s a = Setter s s a a
type Simple (f :: k1 -> k1 -> k2 -> k2 -> k) (s :: k1) (a :: k2) = f s s a a
type Traversal s t a b = forall (f :: Type -> Type). Applicative f => a -> f b -> s -> f t
type Traversal' s a = Traversal s s a a
type Traversal1 s t a b = forall (f :: Type -> Type). Apply f => a -> f b -> s -> f t
type Traversal1' s a = Traversal1 s s a a
class Wrapped s => Rewrapped s t
class (Rewrapped s t, Rewrapped t s) => Rewrapping s t
type family Unwrapped s
class Wrapped s where {
    type family Unwrapped s;
    type Unwrapped s = GUnwrapped Rep s;
}
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
type family Magnified (m :: Type -> Type) :: Type -> Type -> Type
class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify (m :: Type -> Type) (n :: Type -> Type) b a | m -> b, n -> a, m a -> n, n b -> m
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
class (MonadState s m, MonadState t n) => Zoom (m :: Type -> Type) (n :: Type -> Type) s t | m -> s, n -> t, m t -> n, n s -> m
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
type family Zoomed (m :: Type -> Type) :: Type -> Type -> Type
class Profunctor p => Choice (p :: Type -> Type -> Type)
left' :: Choice p => p a b -> p (Either a c) (Either b c)
right' :: Choice p => p a b -> p (Either c a) (Either c b)
data NESet a
class R1 (t :: Type -> Type)
_x :: R1 t => Lens' (t a) a
newtype V1 a
V1 :: a -> V1 a
class R1 t => R2 (t :: Type -> Type)
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)
data V2 a
V2 :: !a -> !a -> V2 a
class R2 t => R3 (t :: Type -> Type)
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)
data V3 a
V3 :: !a -> !a -> !a -> V3 a
class R3 t => R4 (t :: Type -> Type)
_w :: R4 t => Lens' (t a) a
_xyzw :: R4 t => Lens' (t a) (V4 a)
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a
data NEMap k a

-- | It's <a>Point</a>, but with a newtype wrapper so we have an <a>Ord</a>
--   that sorts by y first, then x
newtype ScanPoint
SP :: Point -> ScanPoint
[_getSP] :: ScanPoint -> Point

-- | Represents an orientation of a 2d tile.
data D8
D8 :: !Dir -> !Bool -> D8
[d8Rot] :: D8 -> !Dir
[d8Flip] :: D8 -> !Bool
data Dir
North :: Dir
East :: Dir
South :: Dir
West :: Dir
type FinPoint n = V2 (Finite n)

-- | 2D Coordinate
type Point = V2 Int

-- | Find the minimum and maximum x and y from a collection of points.
--   
--   Returns <tt><a>V2</a> (V2 xMin yMin) (V2 xMax yMax)</tt>.
boundingBox :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> V2 (g a)

-- | A version of <a>boundingBox</a> that works for normal possibly-empty
--   lists.
boundingBox' :: (Foldable f, Applicative g, Ord a) => f (g a) -> Maybe (V2 (g a))
minCorner :: (Foldable1 f, Applicative g, Ord a) => f (g a) -> g a
minCorner' :: (Foldable f, Applicative g, Ord a) => f (g a) -> Maybe (g a)

-- | Shift corner to (0,0)
shiftToZero :: (Applicative f, Num a, Ord a) => NESet (f a) -> NESet (f a)

-- | Shift corner to (0,0)
shiftToZero' :: (Applicative f, Num a, Ord a) => Set (f a) -> Set (f a)
inBoundingBox :: (Applicative g, Foldable g, Ord a) => V2 (g a) -> g a -> Bool
cardinalNeighbs :: Point -> [Point]
cardinalNeighbsSet :: Point -> Set Point
fullNeighbs :: (Applicative f, Num a, Traversable f) => f a -> [f a]
fullNeighbsSet :: (Applicative f, Num a, Ord (f a), Traversable f) => f a -> Set (f a)
memoPoint :: Memo Point
mannDist :: (Foldable f, Num a, Num (f a)) => f a -> f a -> a

-- | Treat as complex number multiplication. useful for rotations
mulPoint :: Num a => V2 a -> V2 a -> V2 a
dirPoint :: Num a => Dir -> V2 a

-- | <a>dirPoint</a> but with inverted y axis
dirPoint' :: Num a => Dir -> V2 a

-- | Rotate a point by a direction
rotPoint :: Num a => Dir -> V2 a -> V2 a

-- | Rotate a point by a direction
rotFin :: KnownNat n => Dir -> FinPoint n -> FinPoint n
centeredFinite :: forall n. KnownNat n => Iso' (Finite n) Rational
parseDir :: Char -> Maybe Dir

-- | Multiply headings, taking North as straight, East as clockwise turn,
--   West as counter-clockwise turn, and South as reverse.
--   
--   Should be a commutative group; it's essentially complex number
--   multiplication like <a>mulPoint</a>, with North = 1, West = i. The
--   identity is <a>North</a> and the inverse is the opposite direction.
mulDir :: Dir -> Dir -> Dir
allDir :: NonEmpty Dir
allDirSet :: NESet Dir

-- | <tt>a <a>mulD8</a> b</tt> represents applying b, then a.
mulD8 :: D8 -> D8 -> D8
allD8 :: NonEmpty D8
allD8Set :: NESet D8

-- | Rotate and flip a point by a <a>D8</a>
orientPoint :: Num a => D8 -> V2 a -> V2 a
orientFin :: KnownNat n => D8 -> FinPoint n -> FinPoint n
parseAsciiMap :: (Char -> Maybe a) -> String -> Map Point a
parseAsciiSet :: (Char -> Bool) -> String -> Set Point
asciiGrid :: IndexedTraversal Point String [a] Char a
displayAsciiMap :: Char -> Map Point Char -> String
displayAsciiSet :: Char -> Char -> Set Point -> String

-- | Lattice points for line between points, not including endpoints
lineTo :: Point -> Point -> [Point]

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Strip trailing newline
stripNewline :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
firstJust :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Generalize a <a>Maybe</a> to any <a>Alternative</a>
maybeAlt :: Alternative m => Maybe a -> m a

-- | Like <a>traceShowId</a> but with an extra message
traceShowIdMsg :: Show a => String -> a -> a

-- | Like <a>traceShow</a> but with an extra message
traceShowMsg :: Show a => String -> a -> b -> b
chop :: ([a] -> (b, [a])) -> [a] -> [b]
chunk :: Int -> [e] -> [[e]]
chunksOf :: Int -> [e] -> [[e]]
condense :: Splitter a -> Splitter a
defaultSplitter :: Splitter a
divvy :: Int -> Int -> [a] -> [[a]]
dropBlanks :: Splitter a -> Splitter a
dropDelims :: Splitter a -> Splitter a
dropFinalBlank :: Splitter a -> Splitter a
dropInitBlank :: Splitter a -> Splitter a
dropInnerBlanks :: Splitter a -> Splitter a
endBy :: Eq a => [a] -> [a] -> [[a]]
endByOneOf :: Eq a => [a] -> [a] -> [[a]]
endsWith :: Eq a => [a] -> Splitter a
endsWithOneOf :: Eq a => [a] -> Splitter a
keepDelimsL :: Splitter a -> Splitter a
keepDelimsR :: Splitter a -> Splitter a
linesBy :: (a -> Bool) -> [a] -> [[a]]
onSublist :: Eq a => [a] -> Splitter a
sepByOneOf :: Eq a => [a] -> [a] -> [[a]]
split :: Splitter a -> [a] -> [[a]]
splitEvery :: Int -> [e] -> [[e]]
splitOn :: Eq a => [a] -> [a] -> [[a]]
splitOneOf :: Eq a => [a] -> [a] -> [[a]]
splitPlaces :: Integral a => [a] -> [e] -> [[e]]
splitPlacesBlanks :: Integral a => [a] -> [e] -> [[e]]
splitWhen :: (a -> Bool) -> [a] -> [[a]]
startsWith :: Eq a => [a] -> Splitter a
startsWithOneOf :: Eq a => [a] -> Splitter a
unintercalate :: Eq a => [a] -> [a] -> [[a]]
whenElt :: (a -> Bool) -> Splitter a
wordsBy :: (a -> Bool) -> [a] -> [[a]]
data Splitter a
between :: Applicative m => m open -> m close -> m a -> m a
choice :: (Foldable f, Alternative m) => f (m a) -> m a
eitherP :: Alternative m => m a -> m b -> m (Either a b)
count :: Monad m => Int -> m a -> m [a]
count' :: MonadPlus m => Int -> Int -> m a -> m [a]
endBy1 :: MonadPlus m => m a -> m sep -> m [a]
manyTill :: MonadPlus m => m a -> m end -> m [a]
manyTill_ :: MonadPlus m => m a -> m end -> m ([a], end)
sepBy :: MonadPlus m => m a -> m sep -> m [a]
sepBy1 :: MonadPlus m => m a -> m sep -> m [a]
sepEndBy :: MonadPlus m => m a -> m sep -> m [a]
sepEndBy1 :: MonadPlus m => m a -> m sep -> m [a]
skipCount :: Monad m => Int -> m a -> m ()
skipMany :: MonadPlus m => m a -> m ()
skipManyTill :: MonadPlus m => m a -> m end -> m end
skipSome :: MonadPlus m => m a -> m ()
skipSomeTill :: MonadPlus m => m a -> m end -> m end
someTill :: MonadPlus m => m a -> m end -> m [a]
someTill_ :: MonadPlus m => m a -> m end -> m ([a], end)
anySingle :: MonadParsec e s m => m (Token s)
anySingleBut :: MonadParsec e s m => Token s -> m (Token s)
noneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)
oneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)
type Parsec e s = ParsecT e s Identity
try :: MonadParsec e s m => m a -> m a
eof :: MonadParsec e s m => m ()
asciiChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
binDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
char :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)
digitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
hexDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
newline :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
octDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)
space :: (MonadParsec e s m, Token s ~ Char) => m ()
space1 :: (MonadParsec e s m, Token s ~ Char) => m ()
string :: MonadParsec e s m => Tokens s -> m (Tokens s)
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)
binary :: (MonadParsec e s m, Token s ~ Char, Num a) => m a
decimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a
float :: (MonadParsec e s m, Token s ~ Char, RealFloat a) => m a
hexadecimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a
octal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a
scientific :: (MonadParsec e s m, Token s ~ Char) => m Scientific
signed :: (MonadParsec e s m, Token s ~ Char, Num a) => m () -> m a -> m a
type ForestF a b = [b]
data TreeF a b
NodeF :: a -> ForestF a b -> TreeF a b
type TokParser s = Parsec Void (TokStream s)
type CharParser = Parsec Void String

-- | Use a stream of tokens <tt>a</tt> as the underlying parser stream.
--   Note that error messages for parser errors are going necessarily to be
--   wonky.
newtype TokStream a
TokStream :: [a] -> TokStream a
[getTokStream] :: TokStream a -> [a]
type Graph v e = Map v (Map v e)
type Letter = Finite 26

-- | trace but only after something has evaluated to WHNF
trace' :: String -> a -> a

-- | Strict (!!)
(!!!) :: [a] -> Int -> a
strictIterate :: (a -> a) -> a -> [a]

-- | Strict drop
drop' :: Int -> [a] -> [a]

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]
(!?) :: [a] -> Int -> Maybe a

-- | Apply function until <a>Nothing</a> is produced, and return last
--   produced value.
loopMaybe :: (a -> Maybe a) -> a -> a

-- | Apply function until a <a>Left</a>.
loopEither :: (a -> Either r a) -> a -> r

-- | Apply monadic function until <a>Nothing</a> is produced, and return
--   last produced value.
loopMaybeM :: Monad m => (a -> m (Maybe a)) -> a -> m a

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Lazily find the first repeated projection.
firstRepeatedBy :: Ord a => (b -> a) -> [b] -> Maybe b

-- | Repeat a function until you get the same result twice.
fixedPoint :: Eq a => (a -> a) -> a -> a

-- | Count the number of items in a container where the predicate is true.
countTrue :: Foldable f => (a -> Bool) -> f a -> Int

-- | Given a map of <tt>k</tt> to possible <tt>a</tt>s for that <tt>k</tt>,
--   find possible configurations where each <tt>k</tt> is given its own
--   unique <tt>a</tt>.
pickUnique :: (Ord k, Ord a) => [(k, Set a)] -> [Map k a]

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | each item paired with the list not including that item
select :: [a] -> [(a, [a])]

-- | Look up a count from a frequency map, defaulting to zero if item is
--   not foudn
lookupFreq :: Ord a => a -> Map a Int -> Int

-- | Build a reverse frequency map
revFreq :: (Foldable f, Ord a) => f a -> IntMap (NESet a)

-- | Build a list of <i>descending</i> frequencies. Ties are sorted.
freqList :: (Foldable f, Ord a) => f a -> [(Int, a)]
eitherItem :: Lens' (Either a a) a
getDown :: Down a -> a
splitWord :: Word8 -> (Finite 16, Finite 16)
decimalDigit :: Prism' Char (Finite 10)
hexDigit :: Prism' Char (Finite 16)

-- | Parse a letter into a number 0 to 25. Returns <a>False</a> if
--   lowercase and <a>True</a> if uppercase.
charFinite :: Char -> Maybe (Bool, Finite 26)
digitToIntSafe :: Char -> Maybe Int

-- | Prism for a <a>Char</a> as <tt>(<a>Bool</a>, <a>Finite</a> 26)</tt>,
--   where the <a>Finite</a> is the letter parsed as a number from 0 to 25,
--   and the <a>Bool</a> is lowercase (<a>False</a>) or uppercase
--   (<a>True</a>).
_CharFinite :: Prism' Char (Bool, Finite 26)

-- | Caeser shift, preserving case. If you have an <a>Int</a> or
--   <a>Integer</a>, convert into <a>Finite</a> using <a>modulo</a>.
caeser :: Finite 26 -> Char -> Char

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: Traversable f => (a -> [a]) -> f a -> [f a]

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbationsBy :: Conjoined p => Over p (Bazaar p a a) s t a a -> (a -> [a]) -> s -> [t]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | sliding windows of a given length
slidingWindows :: Int -> [a] -> [Seq a]

-- | sorted windows of a given length
sortedSlidingWindows :: forall k v. Ord k => Int -> [(k, v)] -> [OrdPSQ k Int v]

-- | sorted windows of a given length
sortedSlidingWindowsInt :: forall v. () => Int -> [(Int, v)] -> [IntPSQ Int v]

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)
foldMapParChunk :: forall a m. (NFData m, Monoid m) => Int -> (a -> m) -> [a] -> m
binaryFold :: Monoid m => Int -> (a -> m) -> [a] -> m
binaryFoldPar :: Monoid m => Int -> (a -> m) -> [a] -> m
listTup :: [a] -> Maybe (a, a)
_ListTup :: Prism' [a] (a, a)
listTup3 :: [a] -> Maybe (a, a, a)
_ListTup3 :: Prism' [a] (a, a, a)
listTup4 :: [a] -> Maybe (a, a, a, a)
_ListTup4 :: Prism' [a] (a, a, a, a)

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <tt>foldMap1</tt>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

-- | Flood fill from a starting set
floodFill :: Ord a => (a -> Set a) -> Set a -> Set a

-- | Flood fill from a starting set, counting the number of steps
floodFillCount :: Ord a => (a -> Set a) -> Set a -> (Int, Set a)
toFGL :: (Graph gr, Ord v) => Graph v e -> (gr v e, Set v)
sortSizedBy :: Vector v a => (a -> a -> Ordering) -> Vector v n a -> Vector v n a
withAllSized :: Vector v a => NonEmpty [a] -> (forall n. KnownNat n => NonEmpty (Vector v n a) -> Maybe r) -> Maybe r

-- | Parse a stream of tokens <tt>s</tt> purely, returning <a>Either</a>
parseTokStream :: Foldable t => Parsec e (TokStream s) a -> t s -> Either (ParseErrorBundle (TokStream s) e) a

-- | Parse a stream of tokens <tt>s</tt> purely
parseTokStream_ :: (Alternative m, Foldable t) => Parsec e (TokStream s) a -> t s -> m a

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad,
--   returning <a>Either</a>
parseTokStreamT :: (Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (Either (ParseErrorBundle (TokStream s) e) a)

-- | Parse a stream of tokens <tt>s</tt> over an underlying monad
parseTokStreamT_ :: (Alternative f, Foldable t, Monad m) => ParsecT e (TokStream s) m a -> t s -> m (f a)
pWord :: (Stream s, Token s ~ Char, Ord e) => Parsec e s String
pHWord :: (Stream s, Token s ~ Char, Ord e) => Parsec e s String
pDecimal :: (Stream s, Token s ~ Char, Ord e, Num a) => Parsec e s a
pTok :: (Stream s, Token s ~ Char, Ord e) => Parsec e s a -> Parsec e s a
pSpace :: (Stream s, Token s ~ Char, Ord e) => Parsec e s ()
parseMaybeLenient :: Parsec Void s a -> s -> Maybe a
parseOrFail :: (Stream s, ShowErrorComponent e) => Parsec e s a -> s -> a
parseLines :: Parsec Void String a -> String -> Maybe [a]
parseWords :: Parsec Void (TokStream String) a -> String -> Maybe a

-- | Skip every result until this token matches
nextMatch :: MonadParsec e s m => m a -> m a
toNatural :: Integral a => a -> Maybe Natural
factorial :: Int -> Int
integerFactorial :: Integer -> Integer
mapMaybeSet :: Ord b => (a -> Maybe b) -> Set a -> Set b
symDiff :: Ord a => Set a -> Set a -> Set a
memo4 :: Memo a -> Memo b -> Memo c -> Memo d -> (a -> b -> c -> d -> r) -> a -> b -> c -> d -> r
anaM :: (Monad m, Corecursive t, Traversable (Base t)) => (a -> m (Base t a)) -> a -> m t
unfoldedIterate :: forall n a proxy. InlineInduction n => proxy n -> (a -> a) -> a -> a

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSolWH] :: (a :~> b) -> SomeSolution
[MkSomeSolNF] :: (NFData a, NFData b) => (a :~> b) -> SomeSolution

-- | Handy pattern to work with both <a>MkSomeSolWH</a> and
--   <a>MkSomeSolNF</a>. As a constructor, just uses <a>MkSomeSolWH</a>, so
--   might not be desirable.
pattern MkSomeSol :: () => forall a b. () => (a :~> b) -> SomeSolution

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> ((?dyno :: DynoMap) => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> (?dyno :: DynoMap) => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Check if a <a>SomeSolution</a> is equipped with an <a>NFData</a>
--   instance on the types
ssIsNF :: SomeSolution -> Bool

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a
data NEIntMap a
data NEIntSet


-- | Template Haskell for discovering all named challenges in a given
--   directory.
module AOC.Discover

-- | Meant to be called like:
--   
--   <pre>
--   mkChallengeMap $$(solutionList "src/AOC/Challenge")
--   </pre>
mkChallengeMap :: [(Day, (Part, SomeSolution))] -> ChallengeMap

-- | Template Haskell splice to produce a list of all named solutions in a
--   directory. Expects solutions as function names following the format
--   <tt>dayDDp</tt>, where <tt>DD</tt> is a two-digit zero-added day, and
--   <tt>p</tt> is a lower-case letter corresponding to the part of the
--   challenge.
--   
--   See <a>mkChallengeMap</a> for a description of usage.
solutionList :: FilePath -> Q (TExp [(Day, (Part, SomeSolution))])

-- | A map of days to parts to solutions.
type ChallengeMap = Map Day (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Day -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Day
[_csPart] :: ChallengeSpec -> Part

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec
solSpecStr :: String -> Either (ParseErrorBundle String Void) ChallengeSpec
solSpecStr_ :: String -> ChallengeSpec

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
challengeName :: Parser ChallengeSpec

-- | Check if a solver identifier is of type <tt>A <a>:~&gt;</a> B</tt>,
--   where <tt>B</tt> is an instance of <a>NFData</a>.
solverNFData :: Name -> Q Bool

-- | Check if a type is an instance of a class, unifying when possible
deepInstance :: Name -> Type -> Q Bool
instance GHC.Classes.Ord AOC.Discover.ChallengeSpec
instance GHC.Classes.Eq AOC.Discover.ChallengeSpec
instance GHC.Show.Show AOC.Discover.ChallengeSpec
instance Data.String.IsString AOC.Discover.ChallengeSpec


-- | Day 25. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day25
day25a :: (Mod Magic, Mod Magic) :~> Integer


-- | Day 24. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day24
day24a :: [[HexDirection]] :~> Int
day24b :: [[HexDirection]] :~> Int
instance GHC.Generics.Generic AOC.Challenge.Day24.Xor
instance Control.DeepSeq.NFData AOC.Challenge.Day24.Xor
instance GHC.Base.Semigroup AOC.Challenge.Day24.Xor
instance GHC.Base.Monoid AOC.Challenge.Day24.Xor


-- | Day 23. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day23
day23a :: Vector Int :~> [Int]
day23b :: Vector Int :~> [Int]


-- | Day 22. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day22
day22a :: (Deck, Deck) :~> Deck
day22b :: (Deck, Deck) :~> Deck
instance GHC.Classes.Eq AOC.Challenge.Day22.GameState
instance GHC.Generics.Generic AOC.Challenge.Day22.Player
instance GHC.Classes.Ord AOC.Challenge.Day22.Player
instance GHC.Classes.Eq AOC.Challenge.Day22.Player
instance GHC.Show.Show AOC.Challenge.Day22.Player
instance Data.Hashable.Class.Hashable AOC.Challenge.Day22.GameState
instance Control.DeepSeq.NFData AOC.Challenge.Day22.Player


-- | Day 21. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day21
day21a :: [(Set String, Set String)] :~> Int
day21b :: [(Set String, Set String)] :~> [String]


-- | Day 20. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day20
day20a :: IntMap (NESet (FinPoint 10)) :~> Int
day20b :: IntMap (NESet (FinPoint 10)) :~> Int


-- | Day 19. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day19
day19a :: (IntMap (Rule Int), [String]) :~> Int
day19b :: (IntMap (Rule Int), [String]) :~> Int
instance GHC.Base.Functor AOC.Challenge.Day19.Rule
instance GHC.Generics.Generic (AOC.Challenge.Day19.Rule a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (AOC.Challenge.Day19.Rule a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AOC.Challenge.Day19.Rule a)
instance GHC.Show.Show a => GHC.Show.Show (AOC.Challenge.Day19.Rule a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (AOC.Challenge.Day19.Rule a)


-- | Day 18. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day18
day18a :: String :~> Int
day18b :: String :~> Int


module AOC.Challenge.Day17
day17a :: Set Point :~> Integer
day17b :: Set Point :~> Integer
runDay17 :: Bool -> Bool -> Int -> Int -> Set Point -> [IntMap IntSet]
ixPascal :: Int -> Int -> [Int]
ixPascalRef :: Int -> Int -> [Int]
pascalIx :: [Int] -> Int
encRun :: Int -> [Int] -> [Int]
pascalVecRunIx :: Vector Int -> Int
vecRunIxPascal :: Int -> Int -> Int -> [Int]
genVecRunIxPascal :: Int -> Int -> Int -> [Int]
oldNeighborWeights :: Int -> Int -> Vector (IntMap NCount)

-- | Streaming/constant space enumerate all neighbor and multiplicities
vecRunNeighbs :: Int -> Int -> Int -> [(Int, NCount)]

-- | Streaming/constant space enumerate all neighbor and multiplicities
vecRunNeighbsInt :: Int -> Int -> Int -> [(Int, Integer)]

-- | Reference implementation for <a>vecRunNeighbs</a>, which takes and
--   returns actual vec run neighbors
vecRunNeighbs_ :: Vector Int -> [(Vector Int, NCount)]

-- | Build up all the weights for quick reference comparison
neighborWeights :: Int -> Int -> Vector (IntMap NCount)
finalWeight :: (Num a, Ord a) => Int -> [a] -> Integer
binom :: Int -> Int -> Int
chompPascal :: Int -> (Int, Int) -> (Int, Int, (Int, Int))
ixChomper :: Int -> Int -> (Int, Int)
ixChomperRef :: Int -> Int -> (Int, Int)
instance GHC.Generics.Generic AOC.Challenge.Day17.LiveCount
instance GHC.Classes.Ord AOC.Challenge.Day17.LiveCount
instance GHC.Classes.Eq AOC.Challenge.Day17.LiveCount
instance GHC.Show.Show AOC.Challenge.Day17.LiveCount
instance GHC.Generics.Generic AOC.Challenge.Day17.NCount
instance GHC.Classes.Ord AOC.Challenge.Day17.NCount
instance GHC.Classes.Eq AOC.Challenge.Day17.NCount
instance GHC.Show.Show AOC.Challenge.Day17.NCount
instance Control.DeepSeq.NFData AOC.Challenge.Day17.LiveCount
instance GHC.Base.Semigroup AOC.Challenge.Day17.LiveCount
instance Control.DeepSeq.NFData AOC.Challenge.Day17.NCount
instance GHC.Base.Semigroup AOC.Challenge.Day17.NCount


-- | Day 16. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day16
day16a :: Info :~> Int
day16b :: Info :~> [Int]
instance GHC.Generics.Generic AOC.Challenge.Day16.Info
instance GHC.Classes.Eq AOC.Challenge.Day16.Info
instance GHC.Show.Show AOC.Challenge.Day16.Info
instance Control.DeepSeq.NFData AOC.Challenge.Day16.Info


-- | Day 15. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day15
day15a :: [Int] :~> Int
day15b :: [Int] :~> Int


-- | Day 14. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day14
day14a :: [Instr] :~> Int
day14b :: [Instr] :~> Int
instance GHC.Generics.Generic AOC.Challenge.Day14.Instr
instance GHC.Classes.Ord AOC.Challenge.Day14.Instr
instance GHC.Classes.Eq AOC.Challenge.Day14.Instr
instance GHC.Show.Show AOC.Challenge.Day14.Instr
instance Control.DeepSeq.NFData AOC.Challenge.Day14.Instr


-- | Day 13. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day13
day13a :: (Int, [Int]) :~> (Int, Int)
day13b :: [(Int, Int)] :~> Int


-- | Day 12. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day12
day12a :: [Instr] :~> Point
day12b :: [Instr] :~> Point
instance GHC.Generics.Generic AOC.Challenge.Day12.Instr
instance GHC.Classes.Eq AOC.Challenge.Day12.Instr
instance GHC.Show.Show AOC.Challenge.Day12.Instr
instance Control.DeepSeq.NFData AOC.Challenge.Day12.Instr


-- | Day 11. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day11
day11a :: Map Point Bool :~> Int
day11b :: Map Point Bool :~> Int


-- | Day 10. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
module AOC.Challenge.Day10
day10a :: [Int] :~> (Int, Int)
day10b :: [Int] :~> Int


-- | Day 9. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day09
day09a :: [Int] :~> Int
day09b :: [Int] :~> (Int, Int)


-- | Day 8. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day08
day08a :: Vector Command :~> Int
day08b :: Vector Command :~> Int
instance Data.Traversable.Traversable AOC.Challenge.Day08.AccStreamF
instance Data.Foldable.Foldable AOC.Challenge.Day08.AccStreamF
instance GHC.Base.Functor AOC.Challenge.Day08.AccStreamF
instance Data.Functor.Foldable.Recursive AOC.Challenge.Day08.AccStream
instance Data.Functor.Foldable.Corecursive AOC.Challenge.Day08.AccStream
instance GHC.Show.Show AOC.Challenge.Day08.EndType
instance GHC.Classes.Ord AOC.Challenge.Day08.EndType
instance GHC.Classes.Eq AOC.Challenge.Day08.EndType
instance GHC.Generics.Generic AOC.Challenge.Day08.EndType
instance GHC.Show.Show AOC.Challenge.Day08.Instr
instance GHC.Classes.Ord AOC.Challenge.Day08.Instr
instance GHC.Classes.Eq AOC.Challenge.Day08.Instr
instance GHC.Generics.Generic AOC.Challenge.Day08.Instr
instance Control.DeepSeq.NFData AOC.Challenge.Day08.EndType
instance Control.DeepSeq.NFData AOC.Challenge.Day08.Instr


-- | Day 7. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day07
day07a :: Graph Bag Int :~> Int
day07b :: Map Bag (Map Bag Int) :~> Int
bagParser :: CharParser (Bag, Map Bag Int)


-- | Day 6. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day06
day06a :: [[String]] :~> Int
day06b :: [[String]] :~> Int


-- | Day 5. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day05
day05a :: [String] :~> Int
day05b :: [String] :~> Int


-- | Day 4. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day04
day04a :: [String] :~> Int
day04b :: [String] :~> Int
instance GHC.Generics.Generic (AOC.Challenge.Day04.Passport f)
instance GHC.Enum.Enum AOC.Challenge.Day04.Eye
instance GHC.Classes.Ord AOC.Challenge.Day04.Eye
instance GHC.Classes.Eq AOC.Challenge.Day04.Eye
instance GHC.Read.Read AOC.Challenge.Day04.Eye
instance GHC.Show.Show AOC.Challenge.Day04.Eye
instance GHC.Classes.Ord AOC.Challenge.Day04.Height
instance GHC.Classes.Eq AOC.Challenge.Day04.Height
instance GHC.Read.Read AOC.Challenge.Day04.Height
instance GHC.Show.Show AOC.Challenge.Day04.Height
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f AOC.Challenge.Day04.Passport => GHC.Show.Show (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Base.Semigroup f AOC.Challenge.Day04.Passport => GHC.Base.Semigroup (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Base.Monoid f AOC.Challenge.Day04.Passport => GHC.Base.Monoid (AOC.Challenge.Day04.Passport f)
instance Barbies.Internal.FunctorB.FunctorB AOC.Challenge.Day04.Passport
instance Barbies.Internal.ApplicativeB.ApplicativeB AOC.Challenge.Day04.Passport
instance Barbies.Internal.TraversableB.TraversableB AOC.Challenge.Day04.Passport
instance Barbies.Internal.ConstraintsB.ConstraintsB AOC.Challenge.Day04.Passport


module AOC.Challenge.Day03
day03a :: String :~> Int
day03b :: String :~> Int
validCoord :: Finite 31 -> Int -> Coord -> Bool


-- | Day 2. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day02
day02a :: [Policy] :~> Int
day02b :: [Policy] :~> Int
instance GHC.Generics.Generic AOC.Challenge.Day02.Policy
instance GHC.Classes.Ord AOC.Challenge.Day02.Policy
instance GHC.Classes.Eq AOC.Challenge.Day02.Policy
instance GHC.Show.Show AOC.Challenge.Day02.Policy
instance Control.DeepSeq.NFData AOC.Challenge.Day02.Policy


-- | Day 1. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day01
day01a :: [Int] :~> Int
day01b :: [Int] :~> Int

-- | Given a goal sum and a set of numbers to pick from, finds the
--   <tt>n</tt> numbers in the set that add to the goal sum. The number of
--   items desired is inferred from the desired length of the return type.
knapsack :: forall n. SNatI n => Int -> IntSet -> Maybe (Vec ('S n) Int)


-- | Gather together all challenges and collect them into a single map.
module AOC.Challenge

-- | A map of days to parts to solutions.
type ChallengeMap = Map Day (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Day -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Day
[_csPart] :: ChallengeSpec -> Part
data Part
Part1 :: Part
Part2 :: Part

-- | A map of all challenges.
challengeMap :: ChallengeMap

-- | Lookup up a solution from a <a>ChallengeMap</a>
lookupSolution :: ChallengeSpec -> Map Day (Map Part a) -> Maybe a
newtype Day
Day :: Finite 25 -> Day
[dayFinite] :: Day -> Finite 25
dayInt :: Day -> Integer
mkDay :: Integer -> Maybe Day
mkDay_ :: Integer -> Day

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part


-- | Loading challenge data and prompts.
module AOC.Run.Load

-- | A record of paths corresponding to a specific challenge.
data ChallengePaths
CP :: !FilePath -> !FilePath -> !FilePath -> !FilePath -> !FilePath -> ChallengePaths
[_cpPrompt] :: ChallengePaths -> !FilePath
[_cpInput] :: ChallengePaths -> !FilePath
[_cpAnswer] :: ChallengePaths -> !FilePath
[_cpTests] :: ChallengePaths -> !FilePath
[_cpLog] :: ChallengePaths -> !FilePath

-- | Generate a <a>ChallengePaths</a> from a specification of a challenge.
challengePaths :: Integer -> ChallengeSpec -> ChallengePaths

-- | A record of data (test inputs, answers) corresponding to a specific
--   challenge.
data ChallengeData
CD :: !Either [String] Text -> !Either [String] String -> !Maybe String -> ![(String, TestMeta)] -> ChallengeData
[_cdPrompt] :: ChallengeData -> !Either [String] Text
[_cdInput] :: ChallengeData -> !Either [String] String
[_cdAnswer] :: ChallengeData -> !Maybe String
[_cdTests] :: ChallengeData -> ![(String, TestMeta)]

-- | Load data associated with a challenge from a given specification. Will
--   fetch answers online and cache if required (and if giten a session
--   token).
challengeData :: Maybe String -> Integer -> ChallengeSpec -> IO ChallengeData
newtype Day
Day :: Finite 25 -> Day
[dayFinite] :: Day -> Finite 25

-- | Run a countdown on the console.
countdownConsole :: MonadIO m => Integer -> Day -> m a -> m a
countdownWithPrint :: MonadIO m => m NominalDiffTime -> Int -> String -> m a -> m a
timeToRelease :: Integer -> Day -> IO NominalDiffTime

-- | Pretty-print a <a>NominalDiffTime</a>
showNominalDiffTime :: NominalDiffTime -> String

-- | Parse a <a>Char</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
showAoCError :: AoCError -> [String]
htmlToMarkdown :: Bool -> Text -> Either [String] Text
mkDay :: Integer -> Maybe Day
mkDay_ :: Integer -> Day
dayInt :: Day -> Integer
data TestMeta
TM :: Maybe String -> Map String Dynamic -> TestMeta
[_tmAnswer] :: TestMeta -> Maybe String
[_tmData] :: TestMeta -> Map String Dynamic
parseMeta :: Parser TestMeta
parseTests :: Parser [(String, TestMeta)]
instance GHC.Show.Show AOC.Run.Load.MetaLine
instance GHC.Show.Show AOC.Run.Load.TestMeta
instance GHC.Show.Show AOC.Run.Load.ChallengePaths


-- | Run actions regarding challenges, solutions, tests, submissions,
--   viewing prompts, etc.
--   
--   Essentially implements the functionality of the main app.
module AOC.Run

-- | Specification of parts to test and run
data TestSpec
TSAll :: TestSpec
TSDayAll :: Day -> TestSpec
[_tsDay] :: TestSpec -> Day
TSDayPart :: ChallengeSpec -> TestSpec
[_tsSpec] :: TestSpec -> ChallengeSpec

-- | Options for <a>mainRun</a>.
data MainRunOpts
MRO :: !TestSpec -> !Bool -> !Bool -> !Bool -> !Bool -> !Day -> Part -> IO (Maybe String) -> MainRunOpts
[_mroSpec] :: MainRunOpts -> !TestSpec

-- | Run input? (Defualt: True
[_mroActual] :: MainRunOpts -> !Bool

-- | Run tests? (Default: False)
[_mroTest] :: MainRunOpts -> !Bool

-- | Benchmark? (Default: False)
[_mroBench] :: MainRunOpts -> !Bool

-- | Lock in answer as correct? (Default: False)
[_mroLock] :: MainRunOpts -> !Bool

-- | Manually supply input (Default: always return Nothing)
[_mroInput] :: MainRunOpts -> !Day -> Part -> IO (Maybe String)
class HasMainRunOpts c_a2Joq
mainRunOpts :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq MainRunOpts
mroActual :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq Bool
mroBench :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq Bool
mroInput :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq (Day -> Part -> IO (Maybe String))
mroLock :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq Bool
mroSpec :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq TestSpec
mroTest :: HasMainRunOpts c_a2Joq => Lens' c_a2Joq Bool

-- | Run, test, bench.
mainRun :: (MonadIO m, MonadError [String] m) => Config -> MainRunOpts -> m (Map Day (Map Part (Maybe Bool, Either [String] String)))

-- | Default options for <a>mainRun</a>.
defaultMRO :: TestSpec -> MainRunOpts

-- | Options for <a>mainView</a>.
data MainViewOpts
MVO :: !TestSpec -> !Bool -> MainViewOpts
[_mvoSpec] :: MainViewOpts -> !TestSpec
[_mvoWait] :: MainViewOpts -> !Bool
class HasMainViewOpts c_a2JvT
mainViewOpts :: HasMainViewOpts c_a2JvT => Lens' c_a2JvT MainViewOpts
mvoSpec :: HasMainViewOpts c_a2JvT => Lens' c_a2JvT TestSpec
mvoWait :: HasMainViewOpts c_a2JvT => Lens' c_a2JvT Bool

-- | View prompt
mainView :: (MonadIO m, MonadError [String] m) => Config -> MainViewOpts -> m (Map Day (Map Part Text))

-- | Default options for <a>mainView</a>.
defaultMVO :: TestSpec -> MainViewOpts

-- | Options for <a>mainSubmit</a>
data MainSubmitOpts
MSO :: !ChallengeSpec -> !Bool -> !Bool -> !Bool -> !Bool -> MainSubmitOpts
[_msoSpec] :: MainSubmitOpts -> !ChallengeSpec

-- | Run tests before submitting? (Default: True)
[_msoTest] :: MainSubmitOpts -> !Bool

-- | Force submission even if bad? (Default: False)
[_msoForce] :: MainSubmitOpts -> !Bool

-- | Lock answer if submission succeeded? (Default: True)
[_msoLock] :: MainSubmitOpts -> !Bool

-- | If a wait is received after submission, try again automatically
--   (Default: False)
[_msoRetry] :: MainSubmitOpts -> !Bool
class HasMainSubmitOpts c_a2JAr
mainSubmitOpts :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr MainSubmitOpts
msoForce :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr Bool
msoLock :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr Bool
msoRetry :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr Bool
msoSpec :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr ChallengeSpec
msoTest :: HasMainSubmitOpts c_a2JAr => Lens' c_a2JAr Bool

-- | Submit and analyze result
mainSubmit :: (MonadIO m, MonadError [String] m) => Config -> MainSubmitOpts -> m (Text, SubmitRes)

-- | Default options for <a>mainSubmit</a>.
defaultMSO :: ChallengeSpec -> MainSubmitOpts

-- | Do the action with a given ANSI foreground color and intensity.
withColor :: ColorIntensity -> Color -> IO () -> IO ()
instance AOC.Run.HasMainSubmitOpts AOC.Run.MainSubmitOpts
instance GHC.Show.Show AOC.Run.MainSubmitOpts
instance AOC.Run.HasMainViewOpts AOC.Run.MainViewOpts
instance GHC.Show.Show AOC.Run.MainViewOpts
instance AOC.Run.HasMainRunOpts AOC.Run.MainRunOpts
instance GHC.Show.Show AOC.Run.TestSpec


-- | Versions of loaders and runners meant to be used in GHCI.
module AOC.Run.Interactive

-- | Run the solution indicated by the challenge spec on the official
--   puzzle input. Get answer as result.
execSolution :: ChallengeSpec -> IO String

-- | Run the solution indicated by the challenge spec on a custom input.
--   Get answer as result.
execSolutionWith :: ChallengeSpec -> String -> IO String

-- | Run test suite for a given challenge spec.
--   
--   Returns <a>Just</a> if any tests were run, with a <a>Bool</a>
--   specifying whether or not all tests passed.
testSolution :: ChallengeSpec -> IO (Maybe Bool)

-- | View the prompt for a given challenge spec.
viewPrompt :: ChallengeSpec -> IO Text

-- | Countdown to get the prompt for a given challenge spec, if not yet
--   available.
waitForPrompt :: ChallengeSpec -> IO Text

-- | Submit solution for a given challenge spec, lock if correct, and retry
--   if a <tt>wait</tt> is received.
submitSolution :: ChallengeSpec -> IO (Text, SubmitRes)

-- | Result-suppressing version of <a>execSolution</a>.
execSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>execSolutionWith</a>.
execSolutionWith_ :: ChallengeSpec -> String -> IO ()

-- | Result-suppressing version of <a>testSolution</a>.
testSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>viewPrompt</a>.
viewPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>waitForPrompt</a>.
waitForPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>submitSolution</a>.
submitSolution_ :: ChallengeSpec -> IO ()

-- | Load input for a given challenge
loadInput :: ChallengeSpec -> IO String

-- | Run the parser of a solution, given its <a>ChallengeSpec</a>.
--   
--   <pre>
--   <a>loadParseInput</a> (solSpec 'day01a) day01a
--   </pre>
loadParseInput :: ChallengeSpec -> (a :~> b) -> IO a

-- | Load test cases for a given challenge
loadTests :: ChallengeSpec -> IO [(String, TestMeta)]

-- | Run the parser of a solution on test data, given its
--   <a>ChallengeSpec</a>.
--   
--   <pre>
--   <a>loadParseTests</a> (solSpec 'day01a) day01a
--   </pre>
loadParseTests :: ChallengeSpec -> (a :~> b) -> IO [(Maybe a, TestMeta)]

-- | Unsafely create a <a>ChallengeSpec</a> from a day number and part.
--   
--   Is undefined if given a day number out of range (1-25).
mkSpec :: Integer -> Part -> ChallengeSpec


-- | Single-stop entry point for the library's functionality and all
--   challenge solutions.
module AOC
